#include "mlp_lock.h"
#include <stdio.h>
#include <stdlib.h>
#include "WaitingQueue.h"
//TODO check that the right path is pointed to by the below #include
#include "RuntimeConflictResolver.h"

#define NOT_AT_FRONT = 3;
#define TRAVERSER_FINISHED = 2;

//Note: is global to all processes
WaitingQueueBinVector * freeBinVectors;

//TODO perhaps print a map of allocSites to arrayIndex?

//NOTE: Only the HashTable calls this function
WaitingQueueBin * mallocWaitingQueue(int size) {
  return (WaitingQueueBin *) malloc(sizeof(WaitingQueueBin) * size);
}

//NOTE: allocSiteID is NOT the same as allocsite, rather it's an ID generated by the traverser for an alloc site for a traversal.
void putWaitingQueue(int allocSiteID, WaitingQueueBin * queue, int effectType, void * resumePtr, int traverserID) {
  //lock bin
  WaitingQueueBinVector * head;
  WaitingQueueBinVector * currentVector;
  TraverserResumeDataFromWaitingQ * b;
  do {
    head = (WaitingQueueBinVector *) 0x1;
    head = LOCKXCHG(&(queue[allocSiteID]).head, head);
  } while (head == (WaitingQueueBinVector *) 0x1);
  //now the current bin is locked.

  //completely empty case
  if (queue[allocSiteID].tail == NULL) {
    currentVector = getUsableVector();
    head = currentVector;
    queue[allocSiteID].tail = currentVector; //We do not set the head here because we need lock
  }
  //Tail bin full
  else if (queue[allocSiteID].tail->tailIndex == NUMITEMS_WQ) {
    currentVector = getUsableVector();
    queue[allocSiteID].tail->next = currentVector;
    queue[allocSiteID].tail = currentVector;
  } else { //the bin not full case
    currentVector = queue[allocSiteID].tail;
  }


  //For the case in which we try to add the same thing twice
  b = &(currentVector->array[currentVector->tailIndex - 1]);
  if(b->effectType == effectType && b->resumePtr == resumePtr && b->traverserID == traverserID) {
    queue[allocSiteID].head = head; // release lock
    return;
  }
  else {//add item
    b = &(currentVector->array[currentVector->tailIndex++]);

    b->resumePtr = resumePtr;
    b->traverserID = traverserID;
    b->effectType = effectType;

    queue[allocSiteID].size++;
    queue[allocSiteID].head = head; // release lock
  }
}


int isEmptyForWaitingQ(WaitingQueueBin * queue, int allocSiteID) {
  return (queue[allocSiteID]).size == 0;
}

//This method should be called by the SESE block
//Return is how many things are removed. -1 would indicate error
int removeFromQueue(WaitingQueueBin * wQueue, int allocSiteID, int TraverserID) {
  TraverserResumeDataFromWaitingQ * td;
  WaitingQueueBin * be = &(wQueue[allocSiteID]);
  int count = 0;

  if(wQueue[allocSiteID].size == 0)
    return -1; //error

  do {
    td = &(be->head->array[be->head->headIndex]);

    //TODO perhaps instead of using traverserID to track which variables are resolved, make
    //individual IDs for each.
    if(td->traverserID != TraverserID) {
      return count;
    }

    //TODo replace 2 with #define
    if(traverse(td->resumePtr, td->traverserID) == 2) {
      count++; // means we at least got rid of 1 item in the traverser
      be->size--;

      //fast case
      if(be->size == 0) {
        be->head->headIndex = 0;
        be->head->tailIndex = 0;
        return count;
      }
      else if(++(be->head->headIndex) == be->head->tailIndex){
        //Note: be->head->next CANNOT be NULL since that would imply be->size == 0
        be->head = returnVectorToFreePool(be->head);
      }
    }
    else
      return count;

  } while(1);
}

WaitingQueueBinVector * returnVectorToFreePool(WaitingQueueBinVector *ptr) {
  WaitingQueueBinVector * freeHead;
  WaitingQueueBinVector * ptrNext;
  do {
    freeHead = (WaitingQueueBinVector *) 0x1;
    //TODO check if this cuts off part of the mem addr or not.
    freeHead = LOCKXCHG(&freeBinVectors, freeHead);
  } while (freeHead == (WaitingQueueBinVector *) 0x1);
  //free bins locked

  ptrNext = ptr->next;
  if(freeHead == NULL) {
    freeBinVectors = ptr; //lock released
  }
  else {
    ptr->next = freeHead;
    freeBinVectors = ptr; //lock released
  }

  return ptrNext;
}

WaitingQueueBinVector * getUsableVector() {
  //Attempt to take one from the free bin first
  WaitingQueueBinVector * ptr;
  do {
    ptr = (WaitingQueueBinVector *) 0x1;
    ptr = LOCKXCHG(&freeBinVectors, ptr);
  } while (ptr == (WaitingQueueBinVector *) 0x1);
  //free bins locked

  if (ptr == NULL) {
    freeBinVectors = NULL; //lock released
    return mallocNewVector();
  } else {
    freeBinVectors = ptr->next; //lock released
    ptr->next = NULL;
    ptr->headIndex = 0;
    ptr->tailIndex = 0;
    return ptr;
  }
}

WaitingQueueBinVector * mallocNewVector() {
  WaitingQueueBinVector * retval = (WaitingQueueBinVector *) malloc(
      sizeof(WaitingQueueBinVector));
  retval->next = NULL;
  retval->headIndex = 0;
  retval->tailIndex = 0;
  return retval;
}

//TODO this only a debug method GET RID OF IT WHEN DONE!!
WaitingQueueBinVector * debug_GetTheFreeBinsPtr() {
  return freeBinVectors;
}

