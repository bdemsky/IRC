#include "mlp_lock.h"
#include <stdio.h>
#include <stdlib.h>
#include "WaitingQueue.h"
#include "hashStructure.h"
//TODO check that the right path is pointed to by the below #include
#include "RuntimeConflictResolver.h"

//Note: is global to all processes
WaitingQueueBinVector * freeBinVectors;

//TODO perhaps print a map of allocSites to arrayIndex?

//NOTE: Only the HashTable calls this function
WaitingQueueBin * mallocWaitingQueue(int size) {
  return (WaitingQueueBin *) malloc(sizeof(WaitingQueueBin) * size);
}

//NOTE: allocSiteID is NOT the same as allocsite, rather it's an ID generated by the traverser for an alloc site for a traversal.
void putIntoWaitingQueue(int allocSiteID, WaitingQueueBin * queue, void * resumePtr, int traverserID) {
  //since Put SHOULD be done only by 1 thread (from 1 hashtable), the locking mechanism is removed.
  WaitingQueueBin *qptr=&queue[allocSiteID];
  WaitingQueueBinVector * tail = qptr->tail;
  int effectType=0;//PLACEHOLDER....EITHER GET RID OF VARIABLE OR PASS IN

  if (tail == NULL) {
    //completely empty case
    WaitingQueueBinVector * currentVector = getUsableWaitingQueueBinVector();
    TraverserResumeDataFromWaitingQ * b = &(currentVector->array[currentVector->tailIndex++]);
    //Add new bin to list
    qptr->head = currentVector;
    qptr->tail = currentVector;
    //Insert item into bin
    b->resumePtr = resumePtr;
    b->traverserID = traverserID;
    b->effectType = effectType;
    qptr->size++;
  } else if (tail->tailIndex == NUMITEMS_WQ) {
    //Tail bin full
    WaitingQueueBinVector * currentVector = tail;
    TraverserResumeDataFromWaitingQ * b = &(currentVector->array[currentVector->tailIndex-1]);
    //Not a duplicate
    if(b->effectType != effectType || b->resumePtr != resumePtr || b->traverserID != traverserID) {
      //should add item
      currentVector = getUsableWaitingQueueBinVector();
      tail->next = currentVector;
      qptr->tail = currentVector;
      b = &(currentVector->array[currentVector->tailIndex++]);
      b->resumePtr = resumePtr;
      b->traverserID = traverserID;
      b->effectType = effectType;
      qptr->size++;
    }
  } else { //the bin not full case
    WaitingQueueBinVector * currentVector = tail;
    TraverserResumeDataFromWaitingQ * b = &(currentVector->array[currentVector->tailIndex-1]);
    //Not a duplicate
    if(b->effectType != effectType || b->resumePtr != resumePtr || b->traverserID != traverserID) {
      //should add item
      b = &(currentVector->array[currentVector->tailIndex++]);
      b->resumePtr = resumePtr;
      b->traverserID = traverserID;
      b->effectType = effectType;
      qptr->size++;
    }
  }
}

int isEmptyForWaitingQ(WaitingQueueBin * queue, int allocSiteID) {
  return queue[allocSiteID].size;
}

//This method should be called by the SESE block
//Return is how many things are removed. -1 would indicate error
int removeFromWaitingQueue(WaitingQueueBin * wQueue, int allocSiteID, int TraverserID) {
  TraverserResumeDataFromWaitingQ * td;
  WaitingQueueBin * be = &(wQueue[allocSiteID]);
  int count = 0;

  if(wQueue[allocSiteID].size == 0)
    return -1; //error

  do {
    td = &(be->head->array[be->head->headIndex]);

    //TODO perhaps instead of using traverserID to track which variables are resolved, make
    //individual IDs for each.
    if(td->traverserID != TraverserID) {
      return count;
    }

    if(traverse(td->resumePtr, td->traverserID) == TRAVERSER_FINISHED) {
      count++; // means we at least got rid of 1 item in the traverser
      be->size--;

      //fast case
      if(be->size == 0) {
        be->head->headIndex = 0;
        be->head->tailIndex = 0;
        return count;
      }
      else if(++(be->head->headIndex) == be->head->tailIndex){
        //Note: be->head->next CANNOT be NULL since that would imply be->size == 0
        be->head = returnWaitingQueueBinVectorToFreePool(be->head);
      }
    }
    else
      return count;

  } while(1);
}

WaitingQueueBinVector * returnWaitingQueueBinVectorToFreePool(WaitingQueueBinVector *ptr) {
  WaitingQueueBinVector * freeHead;
  WaitingQueueBinVector * ptrNext;
  do {
    freeHead = (WaitingQueueBinVector *) 0x1;
    freeHead = (WaitingQueueBinVector *) LOCKXCHG((unsigned INTPTR *)&freeBinVectors, (unsigned INTPTR) freeHead);
  } while (freeHead == (WaitingQueueBinVector *) 0x1);
  //free bins locked

  ptrNext = ptr->next;
  if(freeHead == NULL) {
    freeBinVectors = ptr; //lock released
  }
  else {
    ptr->next = freeHead;
    freeBinVectors = ptr; //lock released
  }

  return ptrNext;
}

WaitingQueueBinVector * getUsableWaitingQueueBinVector() {
  //Attempt to take one from the free bin first
  WaitingQueueBinVector * ptr;
  do {
    ptr = (WaitingQueueBinVector *) 0x1;
    ptr = (WaitingQueueBinVector *) LOCKXCHG((unsigned INTPTR *) &freeBinVectors, (unsigned INTPTR) ptr);
  } while (ptr == (WaitingQueueBinVector *) 0x1);
  //free bins locked

  if (ptr == NULL) {
    freeBinVectors = NULL; //lock released
    return mallocNewWaitingQueueBinVector();
  } else {
    freeBinVectors = ptr->next; //lock released
    ptr->next = NULL;
    ptr->headIndex = 0;
    ptr->tailIndex = 0;
    return ptr;
  }
}

WaitingQueueBinVector * mallocNewWaitingQueueBinVector() {
  WaitingQueueBinVector * retval = (WaitingQueueBinVector *) malloc(
      sizeof(WaitingQueueBinVector));
  retval->next = NULL;
  retval->headIndex = 0;
  retval->tailIndex = 0;
  return retval;
}
