#include "dstm.h"
#include "ip.h"
#include "clookup.h"
#include "machinepile.h"
#include "mlookup.h"
#include "llookup.h"
#include "plookup.h"
#include "prelookup.h"
#include "queue.h"
#include <pthread.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <string.h>
#include <pthread.h>

#define LISTEN_PORT 2156
#define RECEIVE_BUFFER_SIZE 2048
#define NUM_THREADS 10
#define PREFETCH_CACHE_SIZE 1048576 //1MB
#define CONFIG_FILENAME "dstm.conf"

/* Global Variables */
extern int classsize[];
extern primarypfq_t pqueue; //Shared prefetch queue
extern mcpileq_t mcqueue;  //Shared queue containing prefetch requests sorted by remote machineids 
objstr_t *prefetchcache; //Global Prefetch cache
pthread_mutex_t prefetchcache_mutex;// Mutex to lock Prefetch Cache
pthread_mutexattr_t prefetchcache_mutex_attr; /* Attribute for lock to make it a recursive lock */
extern pthread_mutex_t mainobjstore_mutex;// Mutex to lock main Object store
extern prehashtable_t pflookup; //Global Prefetch cache's lookup table
pthread_t wthreads[NUM_THREADS]; //Worker threads for working on the prefetch queue
pthread_t tPrefetch;		/* Primary Prefetch thread that processes the prefetch queue */
extern objstr_t *mainobjstore;
unsigned int myIpAddr;
unsigned int *hostIpAddrs;
int sizeOfHostArray;
int numHostsInSystem;
int myIndexInHostArray;
unsigned int oidsPerBlock;
unsigned int oidMin;
unsigned int oidMax;

void printhex(unsigned char *, int);
plistnode_t *createPiles(transrecord_t *);

void printhex(unsigned char *ptr, int numBytes)
{
	int i;
	for (i = 0; i < numBytes; i++)
	{
		if (ptr[i] < 16)
			printf("0%x ", ptr[i]);
		else
			printf("%x ", ptr[i]);
	}
	printf("\n");
	return;
}

inline int arrayLength(int *array) {
	int i;
	for(i=0 ;array[i] != -1; i++)
		;
	return i;
}
inline int findmax(int *array, int arraylength) {
	int max, i;
	max = array[0];
	for(i = 0; i < arraylength; i++){
		if(array[i] > max) {
			max = array[i];
		}
	}
	return max;
}
/* This function is a prefetch call generated by the compiler that
 * populates the shared primary prefetch queue*/
void prefetch(int ntuples, unsigned int *oids, unsigned short *endoffsets, short *arrayfields) {
	int qnodesize;
	int len = 0;

	/* Allocate for the queue node*/
	char *node;
	if(ntuples > 0) {
		qnodesize = sizeof(prefetchqelem_t) + sizeof(int) + ntuples * (sizeof(short) + sizeof(unsigned int)) + endoffsets[ntuples - 1] * sizeof(short); 
		if((node = calloc(1, qnodesize)) == NULL) {
			printf("Calloc Error %s, %d\n", __FILE__, __LINE__);
			return;
		}
		/* Set queue node values */
		len = sizeof(prefetchqelem_t);
		memcpy(node + len, &ntuples, sizeof(int));
		len += sizeof(int);
		memcpy(node + len, oids, ntuples*sizeof(unsigned int));
		len += ntuples * sizeof(unsigned int);
		memcpy(node + len, endoffsets, ntuples*sizeof(short));
		len += ntuples * sizeof(short);
		memcpy(node + len, arrayfields, endoffsets[ntuples-1]*sizeof(short));
		/* Lock and insert into primary prefetch queue */
		pthread_mutex_lock(&pqueue.qlock);
		pre_enqueue((prefetchqelem_t *)node);
		pthread_cond_signal(&pqueue.qcond);
		pthread_mutex_unlock(&pqueue.qlock);
	}
}

/* This function starts up the transaction runtime. */
int dstmStartup(const char * option) {
  pthread_t thread_Listen;
  pthread_attr_t attr;
  int master=option!=NULL && strcmp(option, "master")==0;

	if (processConfigFile() != 0)
		return 0; //TODO: return error value, cause main program to exit

  dstmInit();
  transInit();

  if (master) {
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    pthread_create(&thread_Listen, &attr, dstmListen, NULL);
    return 1;
  } else {
    dstmListen();
    return 0;
  }

}

//TODO Use this later
void *pCacheAlloc(objstr_t *store, unsigned int size) {
	void *tmp;
	objstr_t *ptr;
	ptr = store;
	int success = 0;

	while(ptr->next != NULL) {
		/* check if store is empty */
		if(((unsigned int)ptr->top - (unsigned int)ptr - sizeof(objstr_t) + size) <= ptr->size) {
			tmp = ptr->top;
			ptr->top += size;
			success = 1;
			return tmp;
		} else {
			ptr = ptr-> next;
		}
	}

	if(success == 0) {
		printf("DEBUG-> Unable to insert object in Prefetch cache\n");
		return NULL;
	}
}

/* This function initiates the prefetch thread
 * A queue is shared between the main thread of execution
 * and the prefetch thread to process the prefetch call
 * Call from compiler populates the shared queue with prefetch requests while prefetch thread
 * processes the prefetch requests */
void transInit() {
	int t, rc;
	int retval;
	//Create and initialize prefetch cache structure
	prefetchcache = objstrCreate(PREFETCH_CACHE_SIZE);
	//prefetchcache->next = objstrCreate(PREFETCH_CACHE_SIZE);
	//prefetchcache->next->next = objstrCreate(PREFETCH_CACHE_SIZE);

	/* Initialize attributes for mutex */
	pthread_mutexattr_init(&prefetchcache_mutex_attr);
	pthread_mutexattr_settype(&prefetchcache_mutex_attr, PTHREAD_MUTEX_RECURSIVE_NP);
	
	pthread_mutex_init(&prefetchcache_mutex, &prefetchcache_mutex_attr);

	//Create prefetch cache lookup table
	if(prehashCreate(HASH_SIZE, LOADFACTOR))
		return; //Failure
	//Initialize primary shared queue
	queueInit();
	//Initialize machine pile w/prefetch oids and offsets shared queue
	mcpileqInit();
	//Create the primary prefetch thread 
	
	do {
	  retval=pthread_create(&tPrefetch, NULL, transPrefetch, NULL);
	} while(retval!=0);
	pthread_detach(tPrefetch);

	//Create and Initialize a pool of threads 
	/* Threads are active for the entire period runtime is running */
	for(t = 0; t< NUM_THREADS; t++) {
	  do {
		rc = pthread_create(&wthreads[t], NULL, mcqProcess, (void *)t);
	  } while(rc!=0);
	  pthread_detach(wthreads[t]);
	}
}

/* This function stops the threads spawned */
void transExit() {
	int t;
	pthread_cancel(tPrefetch);
	for(t = 0; t < NUM_THREADS; t++)
		pthread_cancel(wthreads[t]);

	return;
}

/* This functions inserts randowm wait delays in the order of msec
 * Mostly used when transaction commits retry*/
void randomdelay(void)
{
	struct timespec req, rem;
	time_t t;

	t = time(NULL);
	req.tv_sec = 0;
	req.tv_nsec = (long)(1000000 + (t%10000000)); //1-11 msec
	//nanosleep(&req, &rem);
	nanosleep(&req, NULL);
	return;
}

/* This function initializes things required in the transaction start*/
transrecord_t *transStart()
{
	transrecord_t *tmp = malloc(sizeof(transrecord_t));
	tmp->cache = objstrCreate(1048576);
	tmp->lookupTable = chashCreate(HASH_SIZE, LOADFACTOR);
#ifdef COMPILER
	tmp->revertlist=NULL;
#endif
	return tmp;
}

/* This function finds the location of the objects involved in a transaction
 * and returns the pointer to the object if found in a remote location */
objheader_t *transRead(transrecord_t *record, unsigned int oid) {	
	unsigned int machinenumber;
	objheader_t *tmp, *objheader;
	objheader_t *objcopy;
	int size, rc, found = 0;
	void *buf;
	struct timespec ts;
	struct timeval tp;
        
	rc = gettimeofday(&tp, NULL);

	/* 1ms delay */
	tp.tv_usec += 1000;
	if (tp.tv_usec >= 1000000)
	{
		tp.tv_usec -= 1000000;
		tp.tv_sec += 1;
	}
	/* Convert from timeval to timespec */
	ts.tv_sec = tp.tv_sec;
	ts.tv_nsec = tp.tv_usec * 1000;

	/* Search local transaction cache */
	if((objheader = (objheader_t *)chashSearch(record->lookupTable, oid)) != NULL){
#ifdef COMPILER
	  return &objheader[1];
#else
	  return objheader;
#endif
	} else if ((objheader = (objheader_t *) mhashSearch(oid)) != NULL) {
		/* Look up in machine lookup table  and copy  into cache*/
		GETSIZE(size, objheader);
		size += sizeof(objheader_t);
		objcopy = objstrAlloc(record->cache, size);
		memcpy(objcopy, (void *)objheader, size);
		/* Insert into cache's lookup table */
		chashInsert(record->lookupTable, OID(objheader), objcopy); 
#ifdef COMPILER
		return &objcopy[1];
#else
		return objcopy;
#endif
	} else if((tmp = (objheader_t *) prehashSearch(oid)) != NULL) { /* Look up in prefetch cache */
		GETSIZE(size, tmp);
		size+=sizeof(objheader_t);
		objcopy = objstrAlloc(record->cache, size);
		memcpy(objcopy, (void *)tmp, size);
		/* Insert into cache's lookup table */
		chashInsert(record->lookupTable, OID(tmp), objcopy); 
#ifdef COMPILER
		return &objcopy[1];
#else
		return objcopy;
#endif
	} else {
		/*If object not found in prefetch cache then block until object appears in the prefetch cache */
		pthread_mutex_lock(&pflookup.lock);
		while(!found) {
		 	rc = pthread_cond_timedwait(&pflookup.cond, &pflookup.lock, &ts);
			/* Check Prefetch cache again */
			if((tmp =(objheader_t *) prehashSearch(oid)) != NULL) {
				found = 1;
				GETSIZE(size,tmp);
				size+=sizeof(objheader_t);
				objcopy = objstrAlloc(record->cache, size);
				memcpy(objcopy, (void *)tmp, size);
				chashInsert(record->lookupTable, OID(tmp), objcopy); 
				pthread_mutex_unlock(&pflookup.lock);
#ifdef COMPILER
				return &objcopy[1];
#else
				return objcopy;
#endif
			} else if (rc == ETIMEDOUT) {
//					printf("Wait timed out\n");
					pthread_mutex_unlock(&pflookup.lock);
					break;
			}
		}

		/* Get the object from the remote location */
		machinenumber = lhashSearch(oid);
		objcopy = getRemoteObj(record, machinenumber, oid);
		if(objcopy == NULL) {
			printf("Object not found in Remote location %s, %d\n", __FILE__, __LINE__);
			return NULL;
		} else {
#ifdef COMPILER
		  return &objcopy[1];
#else
		  return objcopy;
#endif
		}
	}
}

/* This function creates objects in the transaction record */
objheader_t *transCreateObj(transrecord_t *record, unsigned int size)
{
  objheader_t *tmp = (objheader_t *) objstrAlloc(record->cache, (sizeof(objheader_t) + size));
  OID(tmp) = getNewOID();
  tmp->version = 1;
  tmp->rcount = 1;
  STATUS(tmp) = NEW;
  chashInsert(record->lookupTable, OID(tmp), tmp);
#ifdef COMPILER
  return &tmp[1]; //want space after object header
#else
  return tmp;
#endif
}

/* This function creates machine piles based on all machines involved in a
 * transaction commit request */
plistnode_t *createPiles(transrecord_t *record) {
	int i = 0;
	unsigned int size;/* Represents number of bins in the chash table */
	chashlistnode_t *curr, *ptr, *next;
	plistnode_t *pile = NULL;
	unsigned int machinenum;
	void *localmachinenum;
	objheader_t *headeraddr;
	
	ptr = record->lookupTable->table;
	size = record->lookupTable->size;

	for(i = 0; i < size ; i++) {
		curr = &ptr[i];
		/* Inner loop to traverse the linked list of the cache lookupTable */
		while(curr != NULL) {
			//if the first bin in hash table is empty
			if(curr->key == 0) {
				break;
			}
			next = curr->next;

			if ((headeraddr = chashSearch(record->lookupTable, curr->key)) == NULL) {
				printf("Error: No such oid %s, %d\n", __FILE__, __LINE__);
				return NULL;
			}

			//Get machine location for object id (and whether local or not)
			if (STATUS(headeraddr) & NEW || mhashSearch(curr->key) != NULL) {
				machinenum = myIpAddr;
			} else	if ((machinenum = lhashSearch(curr->key)) == 0) {
				printf("Error: No such machine %s, %d\n", __FILE__, __LINE__);
				return NULL;
			}

			//Make machine groups
			if ((pile = pInsert(pile, headeraddr, machinenum, record->lookupTable->numelements)) == NULL) {
				printf("pInsert error %s, %d\n", __FILE__, __LINE__);
				return NULL;
			}

			curr = next;
		}
	}
	return pile; 
}

/* This function initiates the transaction commit process
 * Spawns threads for each of the new connections with Participants 
 * and creates new piles by calling the createPiles(), 
 * Sends a transrequest() to each remote machines for objects found remotely 
 * and calls handleLocalReq() to process objects found locally */
int transCommit(transrecord_t *record) {	
	unsigned int tot_bytes_mod, *listmid;
	plistnode_t *pile, *pile_ptr;
	int i, j, rc, val;
	int pilecount, offset, threadnum, trecvcount;
	char buffer[RECEIVE_BUFFER_SIZE],control;
	char transid[TID_LEN];
	trans_req_data_t *tosend;
	trans_commit_data_t transinfo;
	static int newtid = 0;
	char treplyctrl = 0, treplyretry = 0; /* keeps track of the common response that needs to be sent */
	char localstat = 0;

	do {
		trecvcount = 0;
		threadnum = 0;

		/* Look through all the objects in the transaction record and make piles 
		 * for each machine involved in the transaction*/
		pile_ptr = pile = createPiles(record);

		/* Create the packet to be sent in TRANS_REQUEST */

		/* Count the number of participants */
		pilecount = pCount(pile);

		/* Create a list of machine ids(Participants) involved in transaction	*/
		if((listmid = calloc(pilecount, sizeof(unsigned int))) == NULL) {
			printf("Calloc error %s, %d\n", __FILE__, __LINE__);
			free(record);
			return 1;
		}		
		pListMid(pile, listmid);


		/* Initialize thread variables,
		 * Spawn a thread for each Participant involved in a transaction */
		pthread_t thread[pilecount];
		pthread_attr_t attr;			
		pthread_cond_t tcond;
		pthread_mutex_t tlock;
		pthread_mutex_t tlshrd;

		thread_data_array_t *thread_data_array;
		if((thread_data_array = (thread_data_array_t *) malloc(sizeof(thread_data_array_t)*pilecount)) == NULL) {
			printf("Malloc error %s, %d\n", __FILE__, __LINE__);
			pthread_cond_destroy(&tcond);
			pthread_mutex_destroy(&tlock);
			pDelete(pile_ptr);
			free(listmid);
			free(record);
			return 1;
		}

		local_thread_data_array_t *ltdata;
		if((ltdata = calloc(1, sizeof(local_thread_data_array_t))) == NULL) {
			printf("Calloc error %s, %d\n", __FILE__, __LINE__);
			pthread_cond_destroy(&tcond);
			pthread_mutex_destroy(&tlock);
			pDelete(pile_ptr);
			free(listmid);
			free(thread_data_array);
			free(record);
			return 1;
		}

		thread_response_t rcvd_control_msg[pilecount];	/* Shared thread array that keeps track of responses of participants */

		/* Initialize and set thread detach attribute */
		pthread_attr_init(&attr);
		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
		pthread_mutex_init(&tlock, NULL);
		pthread_cond_init(&tcond, NULL);

		/* Process each machine pile */
		while(pile != NULL) {
			//Create transaction id
			newtid++;
			if ((tosend = calloc(1, sizeof(trans_req_data_t))) == NULL) {
				printf("Calloc error %s, %d\n", __FILE__, __LINE__);
				pthread_cond_destroy(&tcond);
				pthread_mutex_destroy(&tlock);
				pDelete(pile_ptr);
				free(listmid);
				free(thread_data_array);
				free(ltdata);
				free(record);
				return 1;
			}
			tosend->f.control = TRANS_REQUEST;
			sprintf(tosend->f.trans_id, "%x_%d", pile->mid, newtid);
			tosend->f.mcount = pilecount;
			tosend->f.numread = pile->numread;
			tosend->f.nummod = pile->nummod;
			tosend->f.numcreated = pile->numcreated;
			tosend->f.sum_bytes = pile->sum_bytes;
			tosend->listmid = listmid;
			tosend->objread = pile->objread;
			tosend->oidmod = pile->oidmod;
			tosend->oidcreated = pile->oidcreated;
			thread_data_array[threadnum].thread_id = threadnum;
			thread_data_array[threadnum].mid = pile->mid;
			thread_data_array[threadnum].buffer = tosend;
			thread_data_array[threadnum].recvmsg = rcvd_control_msg;
			thread_data_array[threadnum].threshold = &tcond;
			thread_data_array[threadnum].lock = &tlock;
			thread_data_array[threadnum].count = &trecvcount;
			thread_data_array[threadnum].replyctrl = &treplyctrl;
			thread_data_array[threadnum].replyretry = &treplyretry;
			thread_data_array[threadnum].rec = record;
			/* If local do not create any extra connection */
			if(pile->mid != myIpAddr) { /* Not local */
			  do {
				rc = pthread_create(&thread[threadnum], &attr, transRequest, (void *) &thread_data_array[threadnum]);  
			  } while(rc!=0);
				if(rc) {
					perror("Error in pthread create\n");
					pthread_cond_destroy(&tcond);
					pthread_mutex_destroy(&tlock);
					pDelete(pile_ptr);
					free(listmid);
					for (i = 0; i < threadnum; i++)
						free(thread_data_array[i].buffer);
					free(thread_data_array);
					free(ltdata);
					free(record);
					return 1;
				}
			} else { /*Local*/
				ltdata->tdata = &thread_data_array[threadnum];
				ltdata->transinfo = &transinfo;
				do {
				val = pthread_create(&thread[threadnum], &attr, handleLocalReq, (void *) ltdata);
				} while(val!=0);
				if(val) {
					perror("Error in pthread create\n");
					pthread_cond_destroy(&tcond);
					pthread_mutex_destroy(&tlock);
					pDelete(pile_ptr);
					free(listmid);
					for (i = 0; i < threadnum; i++)
						free(thread_data_array[i].buffer);
					free(thread_data_array);
					free(ltdata);
					free(record);
					return 1;
				}
			}

			threadnum++;		
			pile = pile->next;
		}

		/* Free attribute and wait for the other threads */
		pthread_attr_destroy(&attr);
		
		for (i = 0; i < pilecount; i++) {
			rc = pthread_join(thread[i], NULL);
			if(rc)
			{
				printf("ERROR return code from pthread_join() is %d\n", rc);
				pthread_cond_destroy(&tcond);
				pthread_mutex_destroy(&tlock);
				pDelete(pile_ptr);
				free(listmid);
				for (j = i; j < pilecount; j++)
					free(thread_data_array[j].buffer);
				free(thread_data_array);
				free(ltdata);
				free(record);
				return 1;
			}
			free(thread_data_array[i].buffer);
		}
	

		/* Free resources */	
		pthread_cond_destroy(&tcond);
		pthread_mutex_destroy(&tlock);
		free(listmid);
		pDelete(pile_ptr);
		free(thread_data_array);
		free(ltdata);

		/* wait a random amount of time */
		if (treplyretry == 1) {
			randomdelay();
		}

	/* Retry trans commit procedure if not sucessful in the first try */
	} while (treplyretry == 1);
	
	/* Free Resources */
	objstrDelete(record->cache);
	chashDelete(record->lookupTable);
	free(record);
	return 0;
}

/* This function sends information involved in the transaction request 
 * to participants and accepts a response from particpants.
 * It calls decideresponse() to decide on what control message 
 * to send next to participants and sends the message using sendResponse()*/
void *transRequest(void *threadarg) {
	int sd, i, n;
	struct sockaddr_in serv_addr;
	struct hostent *server;
	thread_data_array_t *tdata;
	objheader_t *headeraddr;
	char buffer[RECEIVE_BUFFER_SIZE], control, recvcontrol;
	char machineip[16], retval;

	tdata = (thread_data_array_t *) threadarg;

	/* Send Trans Request */
	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("Error in socket for TRANS_REQUEST\n");
		pthread_exit(NULL);
	}
	bzero((char*) &serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(LISTEN_PORT);
	midtoIP(tdata->mid,machineip);
	machineip[15] = '\0';
	serv_addr.sin_addr.s_addr = inet_addr(machineip);
	/* Open Connection */
	if (connect(sd, (struct sockaddr *) &serv_addr, sizeof(struct sockaddr)) < 0) {
		perror("Error in connect for TRANS_REQUEST\n");
		close(sd);
		pthread_exit(NULL);
	}

	/* Send bytes of data with TRANS_REQUEST control message */
	if (send(sd, &(tdata->buffer->f), sizeof(fixed_data_t),MSG_NOSIGNAL) < sizeof(fixed_data_t)) {
		perror("Error sending fixed bytes for thread\n");
		close(sd);
		pthread_exit(NULL);
	}
	/* Send list of machines involved in the transaction */
	{
		int size=sizeof(unsigned int)*tdata->buffer->f.mcount;
		if (send(sd, tdata->buffer->listmid, size, MSG_NOSIGNAL) < size) {
			perror("Error sending list of machines for thread\n");
			close(sd);
			pthread_exit(NULL);
		}
	}
	/* Send oids and version number tuples for objects that are read */
	{
		int size=(sizeof(unsigned int)+sizeof(short))*tdata->buffer->f.numread;
		if (send(sd, tdata->buffer->objread, size, MSG_NOSIGNAL) < size) {
			perror("Error sending tuples for thread\n");
			close(sd);
			pthread_exit(NULL);
		}
	}
	/* Send objects that are modified */
	for(i = 0; i < tdata->buffer->f.nummod ; i++) {
		int size;
		headeraddr = chashSearch(tdata->rec->lookupTable, tdata->buffer->oidmod[i]);
		GETSIZE(size,headeraddr);
		size+=sizeof(objheader_t);
		if (send(sd, headeraddr, size, MSG_NOSIGNAL)  < size) {
			perror("Error sending obj modified for thread\n");
			close(sd);
			pthread_exit(NULL);
		}
	}

	/* Read control message from Participant */
	if((n = read(sd, &control, sizeof(char))) <= 0) {
		perror("Error in reading control message from Participant\n");
		close(sd);
		pthread_exit(NULL);
	}
	recvcontrol = control;

	/* Update common data structure and increment count */
	tdata->recvmsg[tdata->thread_id].rcv_status = recvcontrol;

	/* Lock and update count */
	/* Thread sleeps until all messages from pariticipants are received by coordinator */
	pthread_mutex_lock(tdata->lock);

	(*(tdata->count))++; /* keeps track of no of messages received by the coordinator */

	/* Wake up the threads and invoke decideResponse (once) */
	if(*(tdata->count) == tdata->buffer->f.mcount) {
		decideResponse(tdata); 
		pthread_cond_broadcast(tdata->threshold);
	} else {
		pthread_cond_wait(tdata->threshold, tdata->lock);
	}
	pthread_mutex_unlock(tdata->lock);

	/* Send the final response such as TRANS_COMMIT or TRANS_ABORT t
	 * to all participants in their respective socket */
	if (sendResponse(tdata, sd) == 0) { 
		printf("sendResponse returned error %s,%d\n", __FILE__, __LINE__);
		close(sd);
		pthread_exit(NULL);
	}

	/* Close connection */
	close(sd);
	pthread_exit(NULL);
}

/* This function decides the reponse that needs to be sent to 
 * all Participant machines after the TRANS_REQUEST protocol */
void decideResponse(thread_data_array_t *tdata) {
	char control;
	int i, transagree = 0, transdisagree = 0, transsoftabort = 0; /* Counters to formulate decision of what
									 message to send */

	for (i = 0 ; i < tdata->buffer->f.mcount; i++) {
		control = tdata->recvmsg[i].rcv_status; /* tdata: keeps track of all participant responses
							   written onto the shared array */
		switch(control) {
			default:
				printf("Participant sent unknown message in %s, %d\n", __FILE__, __LINE__);
				/* treat as disagree, pass thru */
			case TRANS_DISAGREE:
				transdisagree++;
				break;

			case TRANS_AGREE:
				transagree++;
				break;

			case TRANS_SOFT_ABORT:
				transsoftabort++;
				break;
		}
	}

	if(transdisagree > 0) {
		/* Send Abort */
		*(tdata->replyctrl) = TRANS_ABORT;
		*(tdata->replyretry) = 0;
		/* clear objects from prefetch cache */
		for (i = 0; i < tdata->buffer->f.numread; i++)
			prehashRemove(*(unsigned int *)(tdata->buffer->objread + (sizeof(unsigned int) + sizeof(unsigned short))*i));
		for (i = 0; i < tdata->buffer->f.nummod; i++)
			prehashRemove(tdata->buffer->oidmod[i]);
	} else if(transagree == tdata->buffer->f.mcount){
		/* Send Commit */
		*(tdata->replyctrl) = TRANS_COMMIT;
		*(tdata->replyretry) = 0;
	} else { 
		/* Send Abort in soft abort case followed by retry commiting transaction again*/
		*(tdata->replyctrl) = TRANS_ABORT;
		*(tdata->replyretry) = 1;
	}

	return;
}
/* This function sends the final response to remote machines per thread in their respective socket id 
 * It returns a char that is only needed to check the correctness of execution of this function inside
 * transRequest()*/
char sendResponse(thread_data_array_t *tdata, int sd) {
	int n, N, sum, oidcount = 0;
	char *ptr, retval = 0;
	unsigned int *oidnotfound;

	/* If the decided response is due to a soft abort and missing objects at the Participant's side */
	if(tdata->recvmsg[tdata->thread_id].rcv_status == TRANS_SOFT_ABORT) {
		/* Read list of objects missing */
		if((read(sd, &oidcount, sizeof(int)) != 0) && (oidcount != 0)) {
			N = oidcount * sizeof(unsigned int);
			if((oidnotfound = calloc(oidcount, sizeof(unsigned int))) == NULL) {
				printf("Calloc error %s, %d\n", __FILE__, __LINE__);
				return 0;
			}
			ptr = (char *) oidnotfound;
			do {
				n = read(sd, ptr+sum, N-sum);
				sum += n;
			} while(sum < N && n !=0);
		}
		retval =  TRANS_SOFT_ABORT;
	}
	/* If the decided response is TRANS_ABORT */
	if(*(tdata->replyctrl) == TRANS_ABORT) {
		retval = TRANS_ABORT;
	} else if(*(tdata->replyctrl) == TRANS_COMMIT) { /* If the decided response is TRANS_COMMIT */
		retval = TRANS_COMMIT;
	}

	if (send(sd, tdata->replyctrl, sizeof(char),MSG_NOSIGNAL) < sizeof(char)) {
		perror("Error sending ctrl message for participant\n");
	}

	return retval;
}

/* This function opens a connection, places an object read request to the 
 * remote machine, reads the control message and object if available  and 
 * copies the object and its header to the local cache.
 * TODO replace mnum and midtoIP() with MACHINE_IP address later */ 

void *getRemoteObj(transrecord_t *record, unsigned int mnum, unsigned int oid) {
	int sd, size, val;
	struct sockaddr_in serv_addr;
	struct hostent *server;
	char control;
	char machineip[16];
	objheader_t *h;
	void *objcopy;

	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("Error in socket\n");
		return NULL;
	}
	bzero((char*) &serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(LISTEN_PORT);
	//serv_addr.sin_addr.s_addr = inet_addr(MACHINE_IP);
	midtoIP(mnum,machineip);
	machineip[15] = '\0';
	serv_addr.sin_addr.s_addr = inet_addr(machineip);
	/* Open connection */
	if (connect(sd, (struct sockaddr *) &serv_addr, sizeof(struct sockaddr)) < 0) {
		perror("Error in connect\n");
		return NULL;
	}
	char readrequest[sizeof(char)+sizeof(unsigned int)];
	readrequest[0] = READ_REQUEST;
	*((unsigned int *)(&readrequest[1])) = oid;
	if (send(sd, &readrequest, sizeof(readrequest), MSG_NOSIGNAL) < sizeof(readrequest)) {
		perror("Error sending message\n");
		return NULL;
	}

	/* Read response from the Participant */
	if((val = read(sd, &control, sizeof(char))) <= 0) {
		perror("No control response for getRemoteObj sent\n");
		return NULL;
	}
	switch(control) {
		case OBJECT_NOT_FOUND:
			return NULL;
		case OBJECT_FOUND:
			/* Read object if found into local cache */
			if((val = read(sd, &size, sizeof(int))) <= 0) {
				perror("No size is read from the participant\n");
				return NULL;
			}
			objcopy = objstrAlloc(record->cache, size);
			if((val = read(sd, objcopy, size)) <= 0) {
				perror("No objects are read from the remote participant\n");
				return NULL;
			}
			/* Insert into cache's lookup table */
			chashInsert(record->lookupTable, oid, objcopy); 
			break;
		default:
			printf("Error in recv request from participant on a READ_REQUEST %s, %d\n",__FILE__, __LINE__);
			return NULL;
	}
	/* Close connection */
	close(sd);
	return objcopy;
}

/* This function handles the local objects involved in a transaction commiting process.
 * It also makes a decision if this local machine sends AGREE or DISAGREE or SOFT_ABORT to coordinator.
 * Note Coordinator = local machine
 * It wakes up the other threads from remote participants that are waiting for the coordinator's decision and
 * based on common agreement it either commits or aborts the transaction.
 * It also frees the memory resources */
void *handleLocalReq(void *threadarg) {
	unsigned int *oidnotfound = NULL, *oidlocked = NULL;
	local_thread_data_array_t *localtdata;
	int objnotfound = 0, objlocked = 0; 
	int v_nomatch = 0, v_matchlock = 0, v_matchnolock = 0;
	int numread, i;
	unsigned int oid;
	unsigned short version;
	void *mobj;
	objheader_t *headptr;

	localtdata = (local_thread_data_array_t *) threadarg;

	/* Counters and arrays to formulate decision on control message to be sent */
	oidnotfound = (unsigned int *) calloc((localtdata->tdata->buffer->f.numread + localtdata->tdata->buffer->f.nummod), sizeof(unsigned int));
	oidlocked = (unsigned int *) calloc((localtdata->tdata->buffer->f.numread + localtdata->tdata->buffer->f.nummod), sizeof(unsigned int));

	numread = localtdata->tdata->buffer->f.numread;
	/* Process each oid in the machine pile/ group per thread */
	for (i = 0; i < localtdata->tdata->buffer->f.numread + localtdata->tdata->buffer->f.nummod; i++) {
		if (i < localtdata->tdata->buffer->f.numread) {
			int incr = sizeof(unsigned int) + sizeof(short);// Offset that points to next position in the objread array
			incr *= i;
			oid = *((unsigned int *)(localtdata->tdata->buffer->objread + incr));
			version = *((short *)(localtdata->tdata->buffer->objread + incr + sizeof(unsigned int)));
		} else { // Objects Modified
			int tmpsize;
			headptr = (objheader_t *) chashSearch(localtdata->tdata->rec->lookupTable, localtdata->tdata->buffer->oidmod[i-numread]);
			if (headptr == NULL) {
				printf("Error: handleLocalReq() returning NULL\n");
				return NULL;
			}
			oid = OID(headptr);
			version = headptr->version;
		}
		/* Check if object is still present in the machine since the beginning of TRANS_REQUEST */

		/* Save the oids not found and number of oids not found for later use */
		if ((mobj = mhashSearch(oid)) == NULL) { /* Obj not found */
			/* Save the oids not found and number of oids not found for later use */
			oidnotfound[objnotfound] = oid;
			objnotfound++;
		} else { /* If Obj found in machine (i.e. has not moved) */
			/* Check if Obj is locked by any previous transaction */
			if ((STATUS(((objheader_t *)mobj)) & LOCK) == LOCK) {
				if (version == ((objheader_t *)mobj)->version) {      /* If locked then match versions */ 
					v_matchlock++;
				} else {/* If versions don't match ...HARD ABORT */
					v_nomatch++;
					/* Send TRANS_DISAGREE to Coordinator */
					localtdata->tdata->recvmsg[localtdata->tdata->thread_id].rcv_status = TRANS_DISAGREE;
				}
			} else {/* If Obj is not locked then lock object */
				STATUS(((objheader_t *)mobj)) |= LOCK;
				/* Save all object oids that are locked on this machine during this transaction request call */
				oidlocked[objlocked] = OID(((objheader_t *)mobj));
				objlocked++;
				if (version == ((objheader_t *)mobj)->version) { /* Check if versions match */
					v_matchnolock++;
				} else { /* If versions don't match ...HARD ABORT */
					v_nomatch++;
					/* Send TRANS_DISAGREE to Coordinator */
					localtdata->tdata->recvmsg[localtdata->tdata->thread_id].rcv_status = TRANS_DISAGREE;
				}
			}
		}
	} // End for
	/* Condition to send TRANS_AGREE */
	if(v_matchnolock == localtdata->tdata->buffer->f.numread + localtdata->tdata->buffer->f.nummod) {
		localtdata->tdata->recvmsg[localtdata->tdata->thread_id].rcv_status = TRANS_AGREE;
	}
	/* Condition to send TRANS_SOFT_ABORT */
	if((v_matchlock > 0 && v_nomatch == 0) || (objnotfound > 0 && v_nomatch == 0)) {
		localtdata->tdata->recvmsg[localtdata->tdata->thread_id].rcv_status = TRANS_SOFT_ABORT;
	}

	/* Fill out the trans_commit_data_t data structure. This is required for a trans commit process
	 * if Participant receives a TRANS_COMMIT */
	localtdata->transinfo->objlocked = oidlocked;
	localtdata->transinfo->objnotfound = oidnotfound;
	localtdata->transinfo->modptr = NULL;
	localtdata->transinfo->numlocked = objlocked;
	localtdata->transinfo->numnotfound = objnotfound;
	/* Lock and update count */
	//Thread sleeps until all messages from pariticipants are received by coordinator
	pthread_mutex_lock(localtdata->tdata->lock);
	(*(localtdata->tdata->count))++; /* keeps track of no of messages received by the coordinator */

	/* Wake up the threads and invoke decideResponse (once) */
	if(*(localtdata->tdata->count) == localtdata->tdata->buffer->f.mcount) {
		decideResponse(localtdata->tdata); 
		pthread_cond_broadcast(localtdata->tdata->threshold);
	} else {
		pthread_cond_wait(localtdata->tdata->threshold, localtdata->tdata->lock);
	}
	pthread_mutex_unlock(localtdata->tdata->lock);
	if(*(localtdata->tdata->replyctrl) == TRANS_ABORT){
		if(transAbortProcess(localtdata) != 0) {
			printf("Error in transAbortProcess() %s,%d\n", __FILE__, __LINE__);
			pthread_exit(NULL);
		}
	} else if(*(localtdata->tdata->replyctrl) == TRANS_COMMIT) {
		if(transComProcess(localtdata) != 0) {
			printf("Error in transComProcess() %s,%d\n", __FILE__, __LINE__);
			pthread_exit(NULL);
		}
	}
	/* Free memory */
	if (localtdata->transinfo->objlocked != NULL) {
		free(localtdata->transinfo->objlocked);
	}
	if (localtdata->transinfo->objnotfound != NULL) {
		free(localtdata->transinfo->objnotfound);
	}

	pthread_exit(NULL);
}

/* This function completes the ABORT process if the transaction is aborting */
int transAbortProcess(local_thread_data_array_t  *localtdata) {
	int i, numlocked;
	unsigned int *objlocked;
	void *header;

	numlocked = localtdata->transinfo->numlocked;
	objlocked = localtdata->transinfo->objlocked;

	for (i = 0; i < numlocked; i++) {
		if((header = mhashSearch(objlocked[i])) == NULL) {
			printf("mhashsearch returns NULL at %s, %d\n", __FILE__, __LINE__);
			return 1;
		}
		STATUS(((objheader_t *)header)) &= ~(LOCK);
	}

	printf("TRANS_ABORTED at Coordinator end\n");

	return 0;
}

/*This function completes the COMMIT process is the transaction is commiting*/
int transComProcess(local_thread_data_array_t  *localtdata) {
	objheader_t *header, *tcptr;
	int i, nummod, tmpsize, numcreated, numlocked;
	unsigned int *oidmod, *oidcreated, *oidlocked;
	void *ptrcreate;

	nummod = localtdata->tdata->buffer->f.nummod;
	oidmod = localtdata->tdata->buffer->oidmod;
	numcreated = localtdata->tdata->buffer->f.numcreated;
	oidcreated = localtdata->tdata->buffer->oidcreated;
	numlocked = localtdata->transinfo->numlocked;
	oidlocked = localtdata->transinfo->objlocked;
	for (i = 0; i < nummod; i++) {
		if((header = (objheader_t *) mhashSearch(oidmod[i])) == NULL) {
			printf("Error: transComProcess() mhashsearch returns NULL at %s, %d\n", __FILE__, __LINE__);
			return 1;
		}
		/* Copy from transaction cache -> main object store */
		if ((tcptr = ((objheader_t *) chashSearch(localtdata->tdata->rec->lookupTable, oidmod[i]))) == NULL) {
			printf("Error: transComProcess() chashSearch returned NULL at %s, %d\n", __FILE__, __LINE__);
			return 1;
		}
		GETSIZE(tmpsize, header);

		pthread_mutex_lock(&mainobjstore_mutex);
		memcpy(header, tcptr, tmpsize + sizeof(objheader_t));
		header->version += 1;
		pthread_mutex_unlock(&mainobjstore_mutex);
	}
	/* If object is newly created inside transaction then commit it */
	for (i = 0; i < numcreated; i++) {
		if ((header = ((objheader_t *) chashSearch(localtdata->tdata->rec->lookupTable, oidcreated[i]))) == NULL) {
			printf("Error: transComProcess() chashSearch returned NULL at %s, %d\n", __FILE__, __LINE__);
			return 1;
		}
		GETSIZE(tmpsize, header);
		pthread_mutex_lock(&mainobjstore_mutex);
		if ((ptrcreate = objstrAlloc(mainobjstore, tmpsize)) == NULL) {
			printf("Error: transComProcess() failed objstrAlloc\n");
			pthread_mutex_unlock(&mainobjstore_mutex);
			return 1;
		}
		pthread_mutex_unlock(&mainobjstore_mutex);
		memcpy(ptrcreate, header, tmpsize + sizeof(objheader_t));

		mhashInsert(oidcreated[i], ptrcreate);
		lhashInsert(oidcreated[i], myIpAddr);
	}
	/* Unlock locked objects */
	for(i = 0; i < numlocked; i++) {
		if((header = (objheader_t *) mhashSearch(oidlocked[i])) == NULL) {
			printf("mhashsearch returns NULL at %s, %d\n", __FILE__, __LINE__);
			return 1;
		}
		STATUS(header) &= ~(LOCK);
	}
	return 0;
}

/* This function checks if the prefetch oids are same and have same offsets  
 * for case x.a.b and y.a.b where x and y have same oid's
 * or if a.b.c is a subset of x.b.c.d*/ 
/* check for case where the generated request a.y.z or x.y.z.g then 
 * prefetch needs to be generated for x.y.z.g  if oid of a and x are same*/
void checkPrefetchTuples(prefetchqelem_t *node) {
	int i,j, count,k, sindex, index;
	char *ptr, *tmp;
	int ntuples, slength;
	unsigned int *oid;
	short *endoffsets, *arryfields; 

	/* Check for the case x.y.z and a.b.c are same oids */ 
	ptr = (char *) node;
	ntuples = *(GET_NTUPLES(ptr));
	oid = GET_PTR_OID(ptr);
	endoffsets = GET_PTR_EOFF(ptr, ntuples); 
	arryfields = GET_PTR_ARRYFLD(ptr, ntuples);
	/* Find offset length for each tuple */
	int numoffset[ntuples];
	numoffset[0] = endoffsets[0];
	for(i = 1; i<ntuples; i++) {
		numoffset[i] = endoffsets[i] - endoffsets[i-1];
	}
	/* Check for redundant tuples by comparing oids of each tuple */
	for(i = 0; i < ntuples; i++) {
		if(oid[i] == 0)
			continue;
		for(j = i+1 ; j < ntuples; j++) {
			if(oid[j] == 0)
				continue;
			/*If oids of tuples match */ 
			if (oid[i] == oid[j]) {
				/* Find the smallest offset length of two tuples*/
				if(numoffset[i] >  numoffset[j]){
					slength = numoffset[j];
					sindex = j;
				}
				else {
					slength = numoffset[i];
					sindex = i;
				}

				/* Compare the offset values based on the current indices
				 * break if they do not match
				 * if all offset values match then pick the largest tuple*/

				if(i == 0) {
					k = 0;
					index = endoffsets[j -1];
					for(count = 0; count < slength; count ++) {
						if (arryfields[k] != arryfields[index]) { 
							break;
						}
						index++;
						k++;
					}	
				} else {
					k = endoffsets[i-1];
					index = endoffsets[j-1];
					for(count = 0; count < slength; count++) {
						if(arryfields[k] != arryfields[index]) {
							break;
						}
						index++;
						k++;
					}
				}

				if(slength == count) {
					oid[sindex] = 0;
				}
			}
		}
	}
}

void checkPreCache(prefetchqelem_t *node, int *numoffset, int counter, int loopcount, unsigned int objoid, int index, int iter, int oidnfound) {
	char *ptr, *tmp;
	int ntuples, i, k, flag;
	unsigned int * oid;
	short *endoffsets, *arryfields;
	objheader_t *header;

	ptr = (char *) node;
	ntuples = *(GET_NTUPLES(ptr));
	oid = GET_PTR_OID(ptr);
	endoffsets = GET_PTR_EOFF(ptr, ntuples);
	arryfields = GET_PTR_ARRYFLD(ptr, ntuples);

	if(oidnfound == 1) {
		if((header = (objheader_t *) prehashSearch(objoid)) == NULL) {
			return;
		} else { //Found in Prefetch Cache
			//TODO Decide if object is too old, if old remove from cache
			tmp = (char *) header;
			/* Check if any of the offset oid is available in the Prefetch cache */
			for(i = counter; i < loopcount; i++) {
				objoid = *(tmp + sizeof(objheader_t) + arryfields[counter]);
				if((header = (objheader_t *)prehashSearch(objoid)) != NULL) {
					flag = 0;
				} else {
					flag = 1;
					break;
				}
			}
		}
	} else {
		for(i = counter; i<loopcount; i++) {
			if((header = (objheader_t *)prehashSearch(objoid)) != NULL) {
				tmp = (char *) header;
				objoid = *(tmp + sizeof(objheader_t) + arryfields[index]);
				flag = 0;
				index++;
			} else {
				flag = 1;
				break;
			}
		}
	}

	/* If oid not found locally or in prefetch cache then 
	 * assign the latest oid found as the new oid 
	 * and copy left over offsets into the arrayoffsetfieldarray*/
	oid[iter] = objoid;
	numoffset[iter] = numoffset[iter] - (i+1);
	for(k = 0; k < numoffset[iter] ; k++) {
		arryfields[endoffsets[counter]+k] = arryfields[endoffsets[counter]+k+1];
	}

	if(flag == 0) {
		oid[iter] = 0;
		numoffset[iter] = 0;
	}
}

/* This function makes machine piles to be added into the machine pile queue for each prefetch call */
prefetchpile_t *makePreGroups(prefetchqelem_t *node, int *numoffset) {
	char *ptr, *tmp;
	int ntuples, slength, i, machinenum;
	int maxoffset;
	unsigned int *oid;
	short *endoffsets, *arryfields, *offset; 
	prefetchpile_t *head = NULL;

	/* Check for the case x.y.z and a.b.c are same oids */ 
	ptr = (char *) node;
	ntuples = *(GET_NTUPLES(ptr));
	oid = GET_PTR_OID(ptr);
	endoffsets = GET_PTR_EOFF(ptr, ntuples); 
	arryfields = GET_PTR_ARRYFLD(ptr, ntuples);

	/* Check for redundant tuples by comparing oids of each tuple */
	for(i = 0; i < ntuples; i++) {
		if(oid[i] == 0)
			continue;
		/* For each tuple make piles */
		if ((machinenum = lhashSearch(oid[i])) == 0) {
			printf("Error: No such Machine %s, %d\n", __FILE__, __LINE__);
			return NULL;
		}
		/* Insert into machine pile */
		offset = &arryfields[endoffsets[i-1]];
		insertPile(machinenum, oid[i], numoffset[i], offset, &head);
	}
	return head;
}


/* This function checks if the oids within the prefetch tuples are available locally.
 * If yes then makes the tuple invalid. If no then rearranges oid and offset values in 
 * the prefetchqelem_t node to represent a new prefetch tuple */
prefetchpile_t *foundLocal(prefetchqelem_t *node) {
	int ntuples,i, j, k, oidnfound = 0, index, flag;
	unsigned int *oid;
	unsigned int  objoid;
	char *ptr, *tmp;
	objheader_t *objheader;
	short *endoffsets, *arryfields; 
	prefetchpile_t *head = NULL;

	ptr = (char *) node;
	ntuples = *(GET_NTUPLES(ptr));
	oid = GET_PTR_OID(ptr);
	endoffsets = GET_PTR_EOFF(ptr, ntuples); 
	arryfields = GET_PTR_ARRYFLD(ptr, ntuples);
	/* Find offset length for each tuple */
	int numoffset[ntuples];//Number of offsets for each tuple
	numoffset[0] = endoffsets[0];
	for(i = 1; i<ntuples; i++) {
		numoffset[i] = endoffsets[i] - endoffsets[i-1];
	}
	for(i = 0; i < ntuples; i++) { 
		if(oid[i] == 0)
			continue;
		/* If object found locally */
		if((objheader = (objheader_t*) mhashSearch(oid[i])) != NULL) { 
			oidnfound = 0;
			tmp = (char *) objheader;
			/* Find the oid of its offset value */
			if(i == 0) 
				index = 0;
			else 
				index = endoffsets[i - 1];
			for(j = 0 ; j < numoffset[i] ; j++) {
				objoid = *(tmp + sizeof(objheader_t) + arryfields[index]);
				/*If oid found locally then 
				 *assign the latest oid found as the new oid 
				 *and copy left over offsets into the arrayoffsetfieldarray*/
				oid[i] = objoid;
				numoffset[i] = numoffset[i] - (j+1);
				for(k = 0; k < numoffset[i]; k++)
					arryfields[endoffsets[j]+ k] = arryfields[endoffsets[j]+k+1];
				index++;
				/*New offset oid not found */
				if((objheader = (objheader_t*) mhashSearch(objoid)) == NULL) {
					flag = 1;
					checkPreCache(node, numoffset, j, numoffset[i], objoid, index, i, oidnfound); 
					break;
				} else 
					flag = 0;
			}

			/*If all offset oids are found locally,make the prefetch tuple invalid */
			if(flag == 0) {
				oid[i] = 0;
				numoffset[i] = 0;
			}
		} else {
			oidnfound = 1;
			/* Look in Prefetch cache */
			checkPreCache(node, numoffset, 0, numoffset[i], oid[i], 0, i, oidnfound); 
		}

	}
	/* Make machine groups */
	head = makePreGroups(node, numoffset);
	return head;
}

/* This function is called by the thread calling transPrefetch */
void *transPrefetch(void *t) {
	prefetchqelem_t *qnode;
	prefetchpile_t *pilehead = NULL;

	while(1) {
		/* lock mutex of primary prefetch queue */
		pthread_mutex_lock(&pqueue.qlock);
		/* while primary queue is empty, then wait */
		while((pqueue.front == NULL) && (pqueue.rear == NULL)) {
			pthread_cond_wait(&pqueue.qcond, &pqueue.qlock);
		}

		/* dequeue node to create a machine piles and  finally unlock mutex */
		if((qnode = pre_dequeue()) == NULL) {
			printf("Error: No node returned %s, %d\n", __FILE__, __LINE__);
			pthread_mutex_unlock(&pqueue.qlock);
			pthread_exit(NULL);
		}
		pthread_mutex_unlock(&pqueue.qlock);
		/* Reduce redundant prefetch requests */
		checkPrefetchTuples(qnode);
		/* Check if the tuples are found locally, if yes then reduce them further*/ 
		/* and group requests by remote machine ids by calling the makePreGroups() */
		pilehead = foundLocal(qnode);

		/* Lock mutex of pool queue */
		pthread_mutex_lock(&mcqueue.qlock);
		/* Update the pool queue with the new remote machine piles generated per prefetch call */
		mcpileenqueue(pilehead);
		/* Broadcast signal on machine pile queue */
		pthread_cond_broadcast(&mcqueue.qcond);
		/* Unlock mutex of  machine pile queue */
		pthread_mutex_unlock(&mcqueue.qlock);
		/* Deallocate the prefetch queue pile node */
		predealloc(qnode);

	}
}

/* Each thread in the  pool of threads calls this function to establish connection with
 * remote machines, send the prefetch requests and process the reponses from
 * the remote machines .
 * The thread is active throughout the period of runtime */

void *mcqProcess(void *threadid) {
	int tid;
	prefetchpile_t *mcpilenode;

	tid = (int) threadid;
	while(1) {
		/* Lock mutex of mc pile queue */
		pthread_mutex_lock(&mcqueue.qlock);
		/* When mc pile queue is empty, wait */
		while((mcqueue.front == NULL) && (mcqueue.rear == NULL)) {
			pthread_cond_wait(&mcqueue.qcond, &mcqueue.qlock);
		}
		/* Dequeue node to send remote machine connections*/
		if((mcpilenode = mcpiledequeue()) == NULL) {
			printf("Dequeue Error: No node returned %s %d\n", __FILE__, __LINE__);
			pthread_mutex_unlock(&mcqueue.qlock);
			pthread_exit(NULL);
		}
		/* Unlock mutex */
		pthread_mutex_unlock(&mcqueue.qlock);

		/*Initiate connection to remote host and send request */ 
		/* Process Request */
		sendPrefetchReq(mcpilenode, tid);

		/* Deallocate the machine queue pile node */
		mcdealloc(mcpilenode);
	}
}

void sendPrefetchReq(prefetchpile_t *mcpilenode, int threadid) {
	int sd, i, offset, off, len, endpair, count = 0;
	struct sockaddr_in serv_addr;
	struct hostent *server;
	char machineip[16], control;
	objpile_t *tmp;


	/* Send Trans Prefetch Request */
	if ((sd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
		perror("Error in socket for TRANS_REQUEST\n");
		return;
	}
	bzero((char*) &serv_addr, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_port = htons(LISTEN_PORT);
	midtoIP(mcpilenode->mid ,machineip);
	machineip[15] = '\0';
	serv_addr.sin_addr.s_addr = inet_addr(machineip);

	/* Open Connection */
	if (connect(sd, (struct sockaddr *) &serv_addr, sizeof(struct sockaddr)) < 0) {
		perror("Error in connect for TRANS_REQUEST\n");
		close(sd);
		return;
	}

	/* Send TRANS_PREFETCH control message */
	control = TRANS_PREFETCH;
	if(send(sd, &control, sizeof(char), MSG_NOSIGNAL) < sizeof(char)) {
		perror("Error in sending prefetch control\n");
		close(sd);
		return;
	}

	/* Send Oids and offsets in pairs */
	tmp = mcpilenode->objpiles;
	while(tmp != NULL) {
		off = offset = 0;
		count++;  /* Keeps track of the number of oid and offset tuples sent per remote machine */
		len = sizeof(int) + sizeof(unsigned int) + ((tmp->numoffset) * sizeof(short));
		char oidnoffset[len];
		memcpy(oidnoffset, &len, sizeof(int));
		off = sizeof(int);
		memcpy(oidnoffset + off, &tmp->oid, sizeof(unsigned int));
		off += sizeof(unsigned int);
		for(i = 0; i < tmp->numoffset; i++) {
			memcpy(oidnoffset + off, &tmp->offset[i], sizeof(short));
			off+=sizeof(short);
		}
		if (send(sd, &oidnoffset, sizeof(oidnoffset),MSG_NOSIGNAL) < sizeof(oidnoffset)) {
			perror("Error sending fixed bytes for thread\n");
			close(sd);
			return;
		}
		tmp = tmp->next;
	}

	/* Send a special char -1 to represent the end of sending oids + offset pair to remote machine */
	endpair = -1;
	if (send(sd, &endpair, sizeof(int), MSG_NOSIGNAL) < sizeof(int)) {
		perror("Error sending fixed bytes for thread\n");
		close(sd);
		return;
	}

	/* Get Response from the remote machine */
	getPrefetchResponse(count,sd);
	close(sd);
	return;
}

void getPrefetchResponse(int count, int sd) {
	int i = 0, val, n, N, sum, index, objsize;
	unsigned int bufsize,oid;
	char buffer[RECEIVE_BUFFER_SIZE], control;
	char *ptr;
	void *modptr, *oldptr;

	/* Read  prefetch response from the Remote machine */
	if((val = read(sd, &control, sizeof(char))) <= 0) {
		perror("No control response for Prefetch request sent\n");
		return;
	}

	if(control == TRANS_PREFETCH_RESPONSE) {
		/*For each oid and offset tuple sent as prefetch request to remote machine*/
		while(i < count) {
			sum = 0;
			index = 0;
			/* Read the size of buffer to be received */
			if((N = read(sd, buffer, sizeof(unsigned int))) <= 0) {
				perror("Size of buffer not recv\n");
				return;
			}
			memcpy(&bufsize, buffer, sizeof(unsigned int));
			ptr = buffer + sizeof(unsigned int);
			/* Keep receiving the buffer containing oid info */ 
			do {
				n = recv((int)sd, (void *)ptr+sum, bufsize-sum, 0);
				sum +=n;
			} while(sum < bufsize && n != 0);
			/* Decode the contents of the buffer */
			index = sizeof(unsigned int);
			while(index < (bufsize - sizeof(unsigned int))) {
				if(buffer[index] == OBJECT_FOUND) {
					/* Increment it to get the object */
					index += sizeof(char);
					memcpy(&oid, buffer + index, sizeof(unsigned int));
					index += sizeof(unsigned int);
					/* For each object found add to Prefetch Cache */
					memcpy(&objsize, buffer + index, sizeof(int));
					index+=sizeof(int);
					pthread_mutex_lock(&prefetchcache_mutex);
					if ((modptr = objstrAlloc(prefetchcache, objsize)) == NULL) {
						printf("objstrAlloc error for copying into prefetch cache %s, %d\n", __FILE__, __LINE__);
						pthread_mutex_unlock(&prefetchcache_mutex);
						return;
					}
					pthread_mutex_unlock(&prefetchcache_mutex);
					memcpy(modptr, buffer+index, objsize);
					index += objsize;
					/* Insert the oid and its address into the prefetch hash lookup table */
					/* Do a version comparison if the oid exists */
					if((oldptr = prehashSearch(oid)) != NULL) {
						/* If older version then update with new object ptr */
						if(((objheader_t *)oldptr)->version < ((objheader_t *)modptr)->version) {
							prehashRemove(oid);
							prehashInsert(oid, modptr);
						} else if(((objheader_t *)oldptr)->version == ((objheader_t *)modptr)->version) { 
							/* Add the new object ptr to hash table */
							prehashRemove(oid);
							prehashInsert(oid, modptr);
						} else { /* Do nothing: TODO modptr should be reference counted */
							;
						}
					} else {/*If doesn't no match found in hashtable, add the object ptr to hash table*/
						prehashInsert(oid, modptr);
					}
					/* Lock the Prefetch Cache look up table*/
					pthread_mutex_lock(&pflookup.lock);
					/* Broadcast signal on prefetch cache condition variable */ 
					pthread_cond_broadcast(&pflookup.cond);
					/* Unlock the Prefetch Cache look up table*/
					pthread_mutex_unlock(&pflookup.lock);
				} else if(buffer[index] == OBJECT_NOT_FOUND) {
					/* Increment it to get the object */
					/* TODO: For each object not found query DHT for new location and retrieve the object */
					index += sizeof(char);
					memcpy(&oid, buffer + index, sizeof(unsigned int));
					index += sizeof(unsigned int);
					/* Throw an error */
					printf("OBJECT NOT FOUND.... THIS SHOULD NOT HAPPEN...TERMINATE PROGRAM\n");
					exit(-1);
				} else {
					printf("Error in decoding the index value %s, %d\n",__FILE__, __LINE__);
					return;
				}
			}

			i++;
		}
	} else
		printf("Error in receving response for prefetch request %s, %d\n",__FILE__, __LINE__);
	return;
}

unsigned short getObjType(unsigned int oid)
{
	objheader_t *objheader;
	unsigned short numoffset[] ={0};
	short fieldoffset[] ={};

	if ((objheader = (objheader_t *) mhashSearch(oid)) == NULL)
	{
		if ((objheader = (objheader_t *) prehashSearch(oid)) == NULL)
		{
			//prefetch(1, &oid, &numoffsets, NULL);
			prefetch(1, &oid, numoffset, fieldoffset);
			pthread_mutex_lock(&pflookup.lock);
			while ((objheader = (objheader_t *) prehashSearch(oid)) == NULL)
			{
				pthread_cond_wait(&pflookup.cond, &pflookup.lock);
			}
			pthread_mutex_unlock(&pflookup.lock);
		}
	}

	return TYPE(objheader);
}

int startRemoteThread(unsigned int oid, unsigned int mid)
{
	int sock;
	struct sockaddr_in remoteAddr;
	char msg[1 + sizeof(unsigned int)];
	int bytesSent;
	int status;

	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
	{
		perror("startRemoteThread():socket()");
		return -1;
	}

	bzero(&remoteAddr, sizeof(remoteAddr));
	remoteAddr.sin_family = AF_INET;
	remoteAddr.sin_port = htons(LISTEN_PORT);
	remoteAddr.sin_addr.s_addr = htonl(mid);
	
	if (connect(sock, (struct sockaddr *)&remoteAddr, sizeof(remoteAddr)) < 0)
	{
		printf("startRemoteThread():error %d connecting to %s:%d\n", errno,
			inet_ntoa(remoteAddr.sin_addr), LISTEN_PORT);
		status = -1;
	}
	else
	{
		msg[0] = START_REMOTE_THREAD;
		memcpy(&msg[1], &oid, sizeof(unsigned int));

		bytesSent = send(sock, msg, 1 + sizeof(unsigned int), 0);
		if (bytesSent < 0)
		{
			perror("startRemoteThread():send()");
			status = -1;
		}
		else if (bytesSent != 1 + sizeof(unsigned int))
		{
			printf("startRemoteThread(): error, sent %d bytes\n", bytesSent);
			status = -1;
		}
		else
		{
			status = 0;
		}
	}

	close(sock);
	return status;
}

//TODO: when reusing oids, make sure they are not already in use!
unsigned int getNewOID(void) {
	static unsigned int id = 0xFFFFFFFF;
	
	id += 2;
	if (id > oidMax || id < oidMin)
	{
		id = (oidMin | 1);
	}
	return id;
}

int processConfigFile()
{
	FILE *configFile;
	const int maxLineLength = 200;
	char lineBuffer[maxLineLength];
	char *token;
	const char *delimiters = " \t\n";
	char *commentBegin;
	in_addr_t tmpAddr;
	
	configFile = fopen(CONFIG_FILENAME, "r");
	if (configFile == NULL)
	{
		printf("error opening %s:\n", CONFIG_FILENAME);
		perror("");
		return -1;
	}

	numHostsInSystem = 0;
	sizeOfHostArray = 8;
	hostIpAddrs = calloc(sizeOfHostArray, sizeof(unsigned int));
	
	while(fgets(lineBuffer, maxLineLength, configFile) != NULL)
	{
		commentBegin = strchr(lineBuffer, '#');
		if (commentBegin != NULL)
			*commentBegin = '\0';
		token = strtok(lineBuffer, delimiters);
		while (token != NULL)
		{
			tmpAddr = inet_addr(token);
			if ((int)tmpAddr == -1)
			{
				printf("error in %s: bad token:%s\n", CONFIG_FILENAME, token);
				fclose(configFile);
				return -1;
			}
			else
				addHost(htonl(tmpAddr));
			token = strtok(NULL, delimiters);
		}
	}

	fclose(configFile);
	
	if (numHostsInSystem < 1)
	{
		printf("error in %s: no IP Adresses found\n", CONFIG_FILENAME);
		return -1;
	}
#ifdef MAC
	myIpAddr = getMyIpAddr("en1");
#else
	myIpAddr = getMyIpAddr("eth0");
#endif
	myIndexInHostArray = findHost(myIpAddr);
	if (myIndexInHostArray == -1)
	{
		printf("error in %s: IP Address of eth0 not found\n", CONFIG_FILENAME);
		return -1;
	}
	oidsPerBlock = (0xFFFFFFFF / numHostsInSystem) + 1;
	oidMin = oidsPerBlock * myIndexInHostArray;
	if (myIndexInHostArray == numHostsInSystem - 1)
		oidMax = 0xFFFFFFFF;
	else
		oidMax = oidsPerBlock * (myIndexInHostArray + 1) - 1;

	return 0;
}

void addHost(unsigned int hostIp)
{
	unsigned int *tmpArray;

	if (findHost(hostIp) != -1)
		return;

	if (numHostsInSystem == sizeOfHostArray)
	{
		tmpArray = calloc(sizeOfHostArray * 2, sizeof(unsigned int));
		memcpy(tmpArray, hostIpAddrs, sizeof(unsigned int) * numHostsInSystem);
		free(hostIpAddrs);
		hostIpAddrs = tmpArray;
	}

	hostIpAddrs[numHostsInSystem++] = hostIp;

	return;
}

int findHost(unsigned int hostIp)
{
	int i;
	for (i = 0; i < numHostsInSystem; i++)
		if (hostIpAddrs[i] == hostIp)
			return i;

	//not found
	return -1;
}

