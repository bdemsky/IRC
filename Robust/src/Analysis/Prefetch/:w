package Analysis.Prefetch;

import java.util.*;
import Analysis.CallGraph.CallGraph;
import Analysis.Prefetch.PrefetchPair;
import IR.SymbolTable;
import IR.State;
import IR.TypeUtil;
import IR.MethodDescriptor;
import IR.Flat.*;
import IR.ClassDescriptor;

public class PrefetchAnalysis {
    State state;
    CallGraph callgraph;
    TypeUtil typeutil;

    public PrefetchAnalysis(State state, CallGraph callgraph, TypeUtil typeutil) {
	this.typeutil=typeutil;
	this.state=state;
	this.callgraph=callgraph;
	DoPrefetch();
    }

    private void DoPrefetch() {
	Iterator classit=state.getClassSymbolTable().getDescriptorsIterator();
	while(classit.hasNext()) {
	    ClassDescriptor cn=(ClassDescriptor)classit.next();
	    doMethodAnalysis(cn);
	}
    }

    private void doMethodAnalysis(ClassDescriptor cn) {
	    Iterator methodit=cn.getMethods();
	    while(methodit.hasNext()) {
		    /* Classify parameters */
		    MethodDescriptor md=(MethodDescriptor)methodit.next();
		    FlatMethod fm=state.getMethodFlat(md);
		    doFlatNodeAnalysis(fm);
		    //tovisit = fm.getNodeSet();
		    //visited = null;
		    //while (!tovisit.isEmpty()) {
		    //	FlatNode fn = tovisit.iterator().next();
		    //	tovisit.remove(fn);
		    //	doFlatNodeAnalysis(fn);
		    //}
	    }
    }

    private void doFlatNodeAnalysis(FlatMethod fm) {
	    HashSet tovisit = new HashSet();
	    //Set<FlatNode> tovisit;
	    Hashtable<FlatNode, PrefetchPair> prefetch_hash = new Hashtable();
	    while(!tovisit.isEmpty()) {
		    FlatNode fn = (FlatNode)tovisit.iterator().next();
		    tovisit.remove(fn);
		    System.out.println("DEBUG -> kind = " + fn.kind());
		    FlatElementNode fen = (FlatElementNode)fn;
		    switch(fn.kind()) {
			    //Take care of all Flat nodes and generate prefetches and analysis for them
			    case FKind.FlatAtomicEnterNode:
				    break;
			    case FKind.FlatAtomicExitNode:
				    break;
			    case FKind.FlatGlobalConvNode:
				    break;
			    case FKind.FlatTagDeclaration:
				    break;
			    case FKind.FlatCall:
				    break;
			    case FKind.FlatFieldNode:
				    FlatFieldNode ffn = (FlatFieldNode) fn;
				    System.out.println("DEBUG -> is an object");
				    System.out.println(ffn.toString());
				    break;
			    case FKind.FlatElementNode:
				    //Set<PrefetchPair> pp = new Set();
				    if (fen.getDst().getType().isPtr()) {
					    System.out.println("DEBUG -> is a pointer");
					    System.out.println(fen.toString());
					    PrefetchPair pp = new PrefetchPair(fen.getDst(),(float)1.0);
					    prefetch_hash.put(fn, pp);
				    }   
				    break;
			    case FKind.FlatSetElementNode:
				    break;
			    case FKind.FlatSetFieldNode:
				    break;
			    case FKind.FlatNew:
				    break;
			    case FKind.FlatOpNode:
				    break;
			    case FKind.FlatCastNode:
				    break;
			    case FKind.FlatLiteralNode:
				    break;
			    case FKind.FlatReturnNode:
				    break;
			    case FKind.FlatNop:
				    System.out.println("/* nop */");
				    break;
			    case FKind.FlatCheckNode:
				    break;
			    case FKind.FlatFlagActionNode:
				    break;
		    }
	    }
    }

    private void doAnalysis() {
	Iterator classit=state.getClassSymbolTable().getDescriptorsIterator();
	while(classit.hasNext()) {
	    ClassDescriptor cn=(ClassDescriptor)classit.next();
	    Iterator methodit=cn.getMethods();
	    while(methodit.hasNext()) {
		/* Classify parameters */
		MethodDescriptor md=(MethodDescriptor)methodit.next();
		FlatMethod fm=state.getMethodFlat(md);
		System.out.println("DEBUG -> ");
		printMethod(fm);
	    }
	}
    }

    private void printMethod(FlatMethod fm) {
	System.out.println(fm.getMethod()+" {");
        HashSet tovisit=new HashSet();
        HashSet visited=new HashSet();
        int labelindex=0;
        Hashtable nodetolabel=new Hashtable();
        tovisit.add(fm);
        FlatNode current_node=null;
        //Assign labels 1st
        //Node needs a label if it is
        while(!tovisit.isEmpty()) {
            FlatNode fn=(FlatNode)tovisit.iterator().next();
            tovisit.remove(fn);
            visited.add(fn);
	    System.out.println("DEBUG -> " + fn.kind());

            for(int i=0;i<fn.numNext();i++) {
                FlatNode nn=fn.getNext(i);
                if(i>0) {
                    //1) Edge >1 of node
                    nodetolabel.put(nn,new Integer(labelindex++));
                }
                if (!visited.contains(nn)&&!tovisit.contains(nn)) {
                    tovisit.add(nn);
                } else {
                    //2) Join point
                    nodetolabel.put(nn,new Integer(labelindex++));
                }
            }
        }
        //Do the actual printing
        tovisit=new HashSet();
        visited=new HashSet();
        tovisit.add(fm);
        while(current_node!=null||!tovisit.isEmpty()) {
            if (current_node==null) {
                current_node=(FlatNode)tovisit.iterator().next();
                tovisit.remove(current_node);
            }
            visited.add(current_node);
            if (nodetolabel.containsKey(current_node))
                System.out.println("L"+nodetolabel.get(current_node)+":");
            if (current_node.numNext()==0) {
		System.out.println("   "+current_node.toString());
		current_node=null;
            } else if(current_node.numNext()==1) {
		System.out.println("   "+current_node.toString());
                FlatNode nextnode=current_node.getNext(0);
                if (visited.contains(nextnode)) {
                    System.out.println("goto L"+nodetolabel.get(nextnode));
                    current_node=null;
                } else
                    current_node=nextnode;
            } else if (current_node.numNext()==2) {
                /* Branch */
                System.out.println("   "+((FlatCondBranch)current_node).toString("L"+nodetolabel.get(current_node.getNext(1))));
                if (!visited.contains(current_node.getNext(1)))
                    tovisit.add(current_node.getNext(1));
                if (visited.contains(current_node.getNext(0))) {
                    System.out.println("goto L"+nodetolabel.get(current_node.getNext(0)));
                    current_node=null;
                } else
                    current_node=current_node.getNext(0);
            } else throw new Error();
        }
        System.out.println("}");
    }

}
