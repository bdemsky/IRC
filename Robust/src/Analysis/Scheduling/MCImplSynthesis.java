package Analysis.Scheduling;

import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.Vector;

import Analysis.OwnershipAnalysis.OwnershipAnalysis;
import Analysis.TaskStateAnalysis.FEdge;
import Analysis.TaskStateAnalysis.FlagState;
import Analysis.TaskStateAnalysis.TaskAnalysis;
import IR.ClassDescriptor;
import IR.State;
import IR.TaskDescriptor;
import IR.TypeUtil;

public class MCImplSynthesis {

  State state;
  ScheduleAnalysis scheduleAnalysis;
  TaskAnalysis taskAnalysis;
  OwnershipAnalysis ownershipAnalysis;
  ScheduleSimulator scheduleSimulator;

  int coreNum;
  int scheduleThreshold; // # of starting points generated by schedule analysis
  int probThreshold; // the probability to stop when no accelaration achieved  
                     // in the directed simulated annealing
  int generateThreshold; // how many optimized implementation generated in 
                         // each iteration of the directed simulated annealing
  int skipThreshold; // the probability to skip to producing more optimization 
                     // with the same root sets(see ScheduleAnalysis.coremapping)

  public MCImplSynthesis(State state, 
                         TaskAnalysis ta,
                         OwnershipAnalysis oa) {
    this.state = state;
    this.coreNum = state.CORENUM;
    this.taskAnalysis = ta;
    this.ownershipAnalysis = oa;
    this.scheduleAnalysis = new ScheduleAnalysis(state,
        ta);
    this.scheduleAnalysis.setCoreNum(this.coreNum);
    this.scheduleSimulator = new ScheduleSimulator(this.coreNum,
        state,
        ta);
    this.scheduleThreshold = 1000;
    this.probThreshold = 0;
    this.generateThreshold = 30;
    this.skipThreshold = 100; // never skip
  }

  public int getCoreNum() {
    return this.scheduleAnalysis.getCoreNum();
  }

  public int getScheduleThreshold() {
    return scheduleThreshold;
  }

  public void setScheduleThreshold(int scheduleThreshold) {
    this.scheduleThreshold = scheduleThreshold;
  }

  public int getProbThreshold() {
    return probThreshold;
  }

  public void setProbThreshold(int probThreshold) {
    this.probThreshold = probThreshold;
  }

  public int getGenerateThreshold() {
    return generateThreshold;
  }

  public void setGenerateThreshold(int generateThreshold) {
    this.generateThreshold = generateThreshold;
  }

  public Vector<Schedule> synthesis() {
    // Print stuff to the original output and error streams.
    // The stuff printed through the 'origOut' and 'origErr' references
    // should go to the console on most systems while the messages
    // printed through the 'System.out' and 'System.err' will end up in
    // the files we created for them.
    //origOut.println ("\nRedirect:  Round #2");
    //System.out.println ("Test output via 'SimulatorResult.out'.");
    //origOut.println ("Test output via 'origOut' reference.");

    // Save the current standard input, output, and error streams
    // for later restoration.
    PrintStream origOut = System.out;

    // Create a new output stream for the stcriticalPathandard output.
    PrintStream stdout  = null;
    try {
      stdout = new PrintStream(
          new FileOutputStream(this.state.outputdir + "SimulatorResult_" 
              + this.coreNum + ".out"));
    } catch (Exception e) {
      // Sigh.  Couldn't open the file.
      System.out.println("Redirect:  Unable to open output file!");
      System.exit(1);
    }

    // Print stuff to the original output and error streams.
    // On most systems all of this will end up on your console when you
    // run this application.
    //origOut.println ("\nRedirect:  Round #1");
    //System.out.println ("Test output via 'System.out'.");
    //origOut.println ("Test output via 'origOut' reference.");

    // Set the System out and err streams to use our replacements.
    System.setOut(stdout);

    Vector<Schedule> scheduling = null;
    Vector<ScheduleNode> schedulinggraph = null;
    int gid = 1;
    
    // check all multi-parameter tasks
    Vector<TaskDescriptor> multiparamtds = new Vector<TaskDescriptor>();
    Iterator it_tasks = 
      this.state.getTaskSymbolTable().getDescriptorsIterator();
    while(it_tasks.hasNext()) {
      TaskDescriptor td = (TaskDescriptor)it_tasks.next();
      if(td.numParameters() > 1) {
        multiparamtds.addElement(td);
      }
    }
    it_tasks = null;

    // generate multiple schedulings
    this.scheduleAnalysis.setScheduleThreshold(this.scheduleThreshold);
    boolean tooptimize = 
      this.scheduleAnalysis.schedule(this.generateThreshold, 
                                     this.skipThreshold,
                                     multiparamtds);
    if(this.generateThreshold > 5) {
      this.generateThreshold = 5;
    }
    this.scheduleSimulator.init();

    Vector<Vector<ScheduleNode>> scheduleGraphs = null;
    Vector<Vector<ScheduleNode>> newscheduleGraphs = 
      this.scheduleAnalysis.getScheduleGraphs();
    Hashtable<TaskDescriptor, ClassDescriptor> td2maincd = 
      this.scheduleAnalysis.getTd2maincd();
    Vector<Vector<Schedule>> schedulings = new Vector<Vector<Schedule>>();
    Vector<Integer> selectedSchedulings = new Vector<Integer>();
    Vector<SimExecutionNode> selectedSimExeGraphs = 
      new Vector<SimExecutionNode>();
    SimExecutionNode selectedSimExeGraph_bk = null;

    int tryindex = 1;
    long bestexetime = Long.MAX_VALUE;
    Random rand = new Random();
    int threshold = this.scheduleThreshold;
    // simulate the generated schedulings and try to optimize it
    do {
      System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
      System.out.print("Simulate and optimize round: #" + tryindex + ": \n");
      gid += newscheduleGraphs.size();
      if(scheduleGraphs != null) {
        for(int i = 0; i < scheduleGraphs.size(); i++) {
          Vector<ScheduleNode> tmpgraph = scheduleGraphs.elementAt(i);
          for(int j = 0; j < tmpgraph.size(); j++) {
            ScheduleNode snode = tmpgraph.elementAt(j);
            snode.getEdgeVector().clear();
            snode.getInedgeVector().clear();
            snode.getScheduleEdges().clear();
            snode.getClassNodes().clear();
          }
          tmpgraph.clear();
          tmpgraph = null;
        }
        scheduleGraphs.clear();
      }
      scheduleGraphs = newscheduleGraphs;
      schedulings.clear();
      // get scheduling layouts from schedule graphs
      for(int i = 0; i < scheduleGraphs.size(); i++) {
        Vector<ScheduleNode> scheduleGraph = scheduleGraphs.elementAt(i);
        Vector<Schedule> tmpscheduling = 
          generateScheduling(scheduleGraph, td2maincd);
        schedulings.add(tmpscheduling);
        scheduleGraph = null;
        tmpscheduling = null;
      }
      selectedSchedulings.clear();
      selectedSimExeGraphs.clear();
      long tmpexetime = this.scheduleSimulator.simulate(schedulings, 
          selectedSchedulings, 
          selectedSimExeGraphs);
      boolean remove = false;
      if(tmpexetime < bestexetime) {
        remove = true;
        bestexetime = tmpexetime;
        if(scheduling != null) {
          scheduling.clear();
          for(int j = 0; j < schedulinggraph.size(); j++) {
            ScheduleNode snode = schedulinggraph.elementAt(j);
            snode.getEdgeVector().clear();
            snode.getInedgeVector().clear();
            snode.getScheduleEdges().clear();
            snode.getClassNodes().clear();
          }
          schedulinggraph.clear();
          selectedSimExeGraph_bk = null;
        }
        scheduling = schedulings.elementAt(selectedSchedulings.elementAt(0));
        schedulinggraph = scheduleGraphs.elementAt(
            selectedSchedulings.elementAt(0));
        selectedSimExeGraph_bk = selectedSimExeGraphs.elementAt(0);
        
        System.out.print("end of: #" + tryindex + " (bestexetime: " 
            + bestexetime + ")\n");
        System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        tryindex++;
        threshold = this.scheduleThreshold;
      } else if(tmpexetime == bestexetime) {
        System.out.print("end of: #" + tryindex + " (bestexetime: " 
            + bestexetime + ")\n");
        System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        tryindex++;
        threshold = this.scheduleThreshold;
        if((Math.abs(rand.nextInt()) % 100) < this.probThreshold) {
          break;
        }
      } else {
        System.out.print("end of: #" + tryindex + " (bestexetime: " 
            + bestexetime + ")\n");
        System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
        tryindex++;
        if(threshold == this.scheduleThreshold) {
          if(scheduleGraphs != null) {
            scheduleGraphs.clear();
          }
          scheduleGraphs.addElement(schedulinggraph);
          if(selectedSchedulings != null) {
            selectedSchedulings.clear();
          }
          selectedSchedulings.addElement(Integer.valueOf(0));
          if(selectedSimExeGraphs != null) {
            selectedSimExeGraphs.clear();
          }
          selectedSimExeGraphs.addElement(selectedSimExeGraph_bk);
        }
        threshold += 10;
        if((Math.abs(rand.nextInt()) % 100) < this.probThreshold + 1) {
          break;
        }
        //break;
      }

      //if(tooptimize) {
      // try to optimize the best one scheduling
      //do {
      newscheduleGraphs = optimizeScheduling(scheduleGraphs, 
          selectedSchedulings, 
          selectedSimExeGraphs,
          gid,
          threshold);
      /*if(newscheduleGraphs != null) {
        if(this.generateThreshold < 30) {
          this.generateThreshold = 30;
        }
        break;
      } else {
        threshold += 10;
        if(this.generateThreshold > 0) {
          this.generateThreshold -= 3;
        }
        if((Math.abs(rand.nextInt()) % 10000) < this.probThreshold + 1) {
          break;
        }
      }
      }while(true);*/
      if(remove) {
        scheduleGraphs.removeElementAt(selectedSchedulings.elementAt(0));
        selectedSimExeGraphs.removeElementAt(0);
      }
      /*} else {
        break;
      }*/
    }while(newscheduleGraphs != null); // TODO: could it possibly lead to endless loop?

    if(scheduleGraphs != null) {
      scheduleGraphs.clear();
    }
    scheduleGraphs = null;
    newscheduleGraphs = null;
    schedulings.clear();
    schedulings = null;
    selectedSchedulings.clear();
    selectedSchedulings = null;
    selectedSimExeGraphs.clear();
    selectedSimExeGraphs = null;

    multiparamtds.clear();
    multiparamtds = null;
    td2maincd.clear();
    td2maincd = null;

    System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    System.out.print("selected bestexetime: " + bestexetime + "\n");
    String path = this.state.outputdir + "scheduling_selected.dot";
    SchedulingUtil.printScheduleGraph(path, schedulinggraph);

    // Close the streams.
    try {
      stdout.close();
      stdout = null;
      System.setOut(origOut);
    } catch (Exception e) {
      origOut.println("Redirect:  Unable to close files!");
    }

    schedulinggraph.clear();
    schedulinggraph = null;

    return scheduling;
  }

  // for test
  // get the distribution info of new search algorithm
  public void distribution(boolean isall, int startnum) {
    // Print stuff to the original output and error streams.
    // The stuff printed through the 'origOut' and 'origErr' references
    // should go to the console on most systems while the messages
    // printed through the 'System.out' and 'System.err' will end up in
    // the files we created for them.
    //origOut.println ("\nRedirect:  Round #2");
    //System.out.println ("Test output via 'SimulatorResult.out'.");
    //origOut.println ("Test output via 'origOut' reference.");

    // Save the current standard input, output, and error streams
    // for later restoration.
    PrintStream origOut = System.out;

    // Create a new output stream for the standard output.
    PrintStream stdout  = null;
    try {
      stdout = new PrintStream(
          new FileOutputStream(this.state.outputdir + "SimulatorResult_" 
              + this.coreNum + ".out"));
    } catch (Exception e) {
      // Sigh.  Couldn't open the file.
      System.out.println("Redirect:  Unable to open output file!");
      System.exit(1);
    }

    // Print stuff to the original output and error streams.
    // On most systems all of this will end up on your console when you
    // run this application.
    //origOut.println ("\nRedirect:  Round #1");
    //System.out.println ("Test output via 'System.out'.");
    //origOut.println ("Test output via 'origOut' reference.");

    // Set the System out and err streams to use our replacements.
    System.setOut(stdout);

    if(isall) {
      // check all multi-parameter tasks
      Vector<TaskDescriptor> multiparamtds = new Vector<TaskDescriptor>();
      Iterator it_tasks = 
        this.state.getTaskSymbolTable().getDescriptorsIterator();
      while(it_tasks.hasNext()) {
        TaskDescriptor td = (TaskDescriptor)it_tasks.next();
        if(td.numParameters() > 1) {
          multiparamtds.addElement(td);
        }
      }
      it_tasks = null;
      
      // Generate all possible schedulings
      //this.scheduleAnalysis.setScheduleThreshold(Integer.MAX_VALUE);
      //this.scheduleAnalysis.schedule(-1, multiparamtds);
      this.scheduleAnalysis.setScheduleThreshold(10000);
      this.scheduleAnalysis.schedule(80, 
                                     20, // might skip
                                     multiparamtds);
      this.scheduleSimulator.init();

      Vector<Vector<ScheduleNode>> totestscheduleGraphs = 
        this.scheduleAnalysis.getScheduleGraphs();
      Hashtable<TaskDescriptor, ClassDescriptor> td2maincd = 
        this.scheduleAnalysis.getTd2maincd();
      Vector<Vector<Schedule>> schedulings = new Vector<Vector<Schedule>>();
      Vector<Integer> selectedSchedulings = new Vector<Integer>();
      Vector<SimExecutionNode> selectedSimExeGraphs = 
        new Vector<SimExecutionNode>();
      
      File file=new File(this.state.outputdir+"distributeinfo_s_"+this.coreNum
                         +".out");
      FileOutputStream dotstream = null; 
      try {
        dotstream = new FileOutputStream(file,false);
      } catch (Exception e) {
        e.printStackTrace();
        System.exit(-1);
      }
      PrintWriter output = new java.io.PrintWriter(dotstream, true);
      output.println("start time(1,000,000 cycles): " 
                     + totestscheduleGraphs.size());
      for(int ii = 0; ii < totestscheduleGraphs.size(); ii++) {
        Vector<Vector<ScheduleNode>> newscheduleGraphs = 
          new Vector<Vector<ScheduleNode>>();
        newscheduleGraphs.add(totestscheduleGraphs.elementAt(ii));
        // simulate the generated schedulings and try to optimize it   
        schedulings.clear();
        // get scheduling layouts from schedule graphs
        for(int i = 0; i < newscheduleGraphs.size(); i++) {
          Vector<ScheduleNode> scheduleGraph = newscheduleGraphs.elementAt(i);
          Vector<Schedule> tmpscheduling = 
            generateScheduling(scheduleGraph, td2maincd);
          schedulings.add(tmpscheduling);
          scheduleGraph = null;
          tmpscheduling = null;
        }
        selectedSchedulings.clear();
        selectedSimExeGraphs.clear();
        long tmpexetime = this.scheduleSimulator.simulate(schedulings, 
            selectedSchedulings, 
            selectedSimExeGraphs);
        output.println(((float)tmpexetime/100000000));
      }

    } else {
      // check all multi-parameter tasks
      Vector<TaskDescriptor> multiparamtds = new Vector<TaskDescriptor>();
      Iterator it_tasks = 
        this.state.getTaskSymbolTable().getDescriptorsIterator();
      while(it_tasks.hasNext()) {
        TaskDescriptor td = (TaskDescriptor)it_tasks.next();
        if(td.numParameters() > 1) {
          multiparamtds.addElement(td);
        }
      }
      it_tasks = null;
      
      // generate multiple schedulings
      this.scheduleThreshold = 20;
      this.generateThreshold = 30;
      this.probThreshold = 0;
      this.scheduleAnalysis.setScheduleThreshold(1000);
      boolean tooptimize = 
        this.scheduleAnalysis.schedule(this.generateThreshold, 
                                       60, // might skip
                                       multiparamtds);
      this.scheduleSimulator.init();

      Vector<Vector<ScheduleNode>> scheduleGraphs = null;
      Vector<Vector<ScheduleNode>> totestscheduleGraphs = 
        this.scheduleAnalysis.getScheduleGraphs();
      Hashtable<TaskDescriptor, ClassDescriptor> td2maincd = 
        this.scheduleAnalysis.getTd2maincd();
      Vector<Vector<Schedule>> schedulings = new Vector<Vector<Schedule>>();
      Vector<Integer> selectedSchedulings = new Vector<Integer>();
      Vector<SimExecutionNode> selectedSimExeGraphs = 
        new Vector<SimExecutionNode>();
      SimExecutionNode selectedSimExeGraph_bk = null;

      File file=new File(this.state.outputdir + "distributeinfo_s_" 
                         + this.coreNum + ".out");
      FileOutputStream dotstream = null; 
      File file2=new File(this.state.outputdir + "distributeinfo_o_" 
                          + this.coreNum + ".out");
      FileOutputStream dotstream2 = null; 
      try {
        dotstream = new FileOutputStream(file,false);
        dotstream2 = new FileOutputStream(file2,false);
      } catch (Exception e) {
        e.printStackTrace();
        System.exit(-1);
      }
      PrintWriter output = new java.io.PrintWriter(dotstream, true);
      PrintWriter output2 = new java.io.PrintWriter(dotstream2, true);
      output.println("start time(100,000,000 cycles): " 
                     + totestscheduleGraphs.size());
      output2.println("optimized time(100,000,000 cycles): " 
                      + totestscheduleGraphs.size());
      for(int ii = startnum; ii < totestscheduleGraphs.size(); ii++) {
        Vector<Vector<ScheduleNode>> newscheduleGraphs = 
          new Vector<Vector<ScheduleNode>>();
        newscheduleGraphs.add(totestscheduleGraphs.elementAt(ii));
        int tryindex = 1;
        long bestexetime = Long.MAX_VALUE;
        int gid = 1;
        Vector<Schedule> scheduling = null;
        Vector<ScheduleNode> schedulinggraph = null;
        boolean isfirst = true;
        Random rand = new Random();
        int threshold = this.scheduleThreshold;
        // simulate the generated schedulings and try to optimize it
        System.out.print("=========================================================\n");
        System.out.print("# " + ii + ": \n");
        do {
          System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
          System.out.print("Simulate and optimize round: #" + tryindex + ": \n");    
          gid += newscheduleGraphs.size();
          if(scheduleGraphs != null) {
            for(int i = 0; i < scheduleGraphs.size(); i++) {
              Vector<ScheduleNode> tmpgraph = scheduleGraphs.elementAt(i);
              for(int j = 0; j < tmpgraph.size(); j++) {
                ScheduleNode snode = tmpgraph.elementAt(j);
                snode.getEdgeVector().clear();
                snode.getInedgeVector().clear();
                snode.getScheduleEdges().clear();
                snode.getClassNodes().clear();
              }
              tmpgraph.clear();
              tmpgraph = null;
            }
            scheduleGraphs.clear();
          }
          scheduleGraphs = newscheduleGraphs;
          schedulings.clear();
          // get scheduling layouts from schedule graphs
          for(int i = 0; i < scheduleGraphs.size(); i++) {
            Vector<ScheduleNode> scheduleGraph = scheduleGraphs.elementAt(i);
            Vector<Schedule> tmpscheduling = 
              generateScheduling(scheduleGraph, td2maincd);
            schedulings.add(tmpscheduling);
            scheduleGraph = null;
            tmpscheduling = null;
          }
          selectedSchedulings.clear();
          selectedSimExeGraphs.clear();
          long tmpexetime = this.scheduleSimulator.simulate(schedulings, 
              selectedSchedulings, 
              selectedSimExeGraphs);
          if(isfirst) {
            output.println(((float)tmpexetime/100000000));
            isfirst = false;
          }
          if(tmpexetime < bestexetime) {
            bestexetime = tmpexetime;
            if(scheduling != null) {
              scheduling.clear();
              for(int j = 0; j < schedulinggraph.size(); j++) {
                ScheduleNode snode = schedulinggraph.elementAt(j);
                snode.getEdgeVector().clear();
                snode.getInedgeVector().clear();
                snode.getScheduleEdges().clear();
                snode.getClassNodes().clear();
              }
              schedulinggraph.clear();
              selectedSimExeGraph_bk = null;
            }
            scheduling = schedulings.elementAt(selectedSchedulings.elementAt(0));
            schedulinggraph = scheduleGraphs.elementAt(
                selectedSchedulings.elementAt(0));
            selectedSimExeGraph_bk = selectedSimExeGraphs.elementAt(0);
            tryindex++;
            threshold = this.scheduleThreshold;
            System.out.print("end of: #" + tryindex + " (bestexetime: " 
                             + bestexetime + ")\n");
            System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
          } else if(tmpexetime == bestexetime) {
            System.out.print("end of: #" + tryindex + " (bestexetime: " 
                             + bestexetime + ")\n");
            System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
            tryindex++;
            threshold = this.scheduleThreshold;
            if((Math.abs(rand.nextInt()) % 100) < this.probThreshold) {
              break;
            }
          } else {
            System.out.print("end of: #" + tryindex + " (bestexetime: " 
                + bestexetime + ")\n");
            System.out.print("+++++++++++++++++++++++++++++++++++++++++++++++++++\n");
            tryindex++;
            if(threshold == this.scheduleThreshold) {
              if(scheduleGraphs != null) {
                scheduleGraphs.clear();
              }
              scheduleGraphs.addElement(schedulinggraph);
              if(selectedSchedulings != null) {
                selectedSchedulings.clear();
              }
              selectedSchedulings.addElement(Integer.valueOf(0));
              if(selectedSimExeGraphs != null) {
                selectedSimExeGraphs.clear();
              }
              selectedSimExeGraphs.addElement(selectedSimExeGraph_bk);
            }
            threshold += 10;
            if((Math.abs(rand.nextInt()) % 100) < this.probThreshold + 1) {
              break;
            }
            //break;
          }

          if(tooptimize) {
          // try to optimize theschedulings best one scheduling
          newscheduleGraphs = optimizeScheduling(scheduleGraphs, 
              selectedSchedulings, 
              selectedSimExeGraphs,
              gid,
              this.scheduleThreshold);
          if(tmpexetime < bestexetime) {
            scheduleGraphs.remove(selectedSchedulings.elementAt(0));
          }
          } else {
            break;
          }
        }while(newscheduleGraphs != null); // TODO: could it possibly lead to endless loop?

        scheduleGraphs.clear();
        scheduleGraphs = null;
        scheduling = null;
        schedulinggraph = null;
        if(newscheduleGraphs != null) {
          newscheduleGraphs.clear();
        }
        newscheduleGraphs = null;
        totestscheduleGraphs.elementAt(ii).clear();
        for(int i = 0; i < schedulings.size(); i++) {
          schedulings.elementAt(i).clear();
        }
        schedulings.clear();
        selectedSchedulings.clear();
        selectedSimExeGraphs.clear();

        output2.println(((float)bestexetime/100000000));
        System.out.print("=========================================================\n");
      }

      if(scheduleGraphs != null) {
        scheduleGraphs.clear();
      }
      scheduleGraphs = null;
      totestscheduleGraphs = null;
      for(int i = 0; i < schedulings.size(); i++) {
        schedulings.elementAt(i).clear();
      }
      schedulings.clear();
      schedulings = null;
      selectedSchedulings.clear();
      selectedSchedulings = null;
      selectedSimExeGraphs.clear();
      selectedSimExeGraphs = null;
      multiparamtds.clear();
      multiparamtds = null;
      td2maincd.clear();
      td2maincd = null;

      // Close the streams.
      try {
        output.close();
        stdout.close();
        output = null;
        stdout = null;
        System.setOut(origOut);
      } catch (Exception e) {
        origOut.println("Redirect:  Unable to close files!");
      }
    }

    return;
  }

  private Vector<Vector<ScheduleNode>> 
  optimizeScheduling(Vector<Vector<ScheduleNode>> scheduleGraphs,
                     Vector<Integer> selectedScheduleGraphs,
                     Vector<SimExecutionNode> selectedSimExeGraphs,
                     int gid,
                     int count) {
    if(this.coreNum == 1) {
      // single core
      return null;
    }

    Vector<Vector<ScheduleNode>> optimizeschedulegraphs = null;
    int lgid = gid;
    int left = count;

    for(int i = 0; i < selectedScheduleGraphs.size(); i++) {
      Vector<ScheduleNode> schedulegraph = scheduleGraphs.elementAt(
          selectedScheduleGraphs.elementAt(i));
      SimExecutionNode startnode = selectedSimExeGraphs.elementAt(i);
      Vector<SimExecutionEdge> criticalPath = analyzeCriticalPath(startnode); 
      // for Test
      if(this.state.PRINTCRITICALPATH) {
        System.err.println("gid: " + lgid + " endpoint: " + startnode.getTimepoint());
      }
      Vector<Vector<ScheduleNode>> tmposchedulegraphs = 
        optimizeCriticalPath(schedulegraph, 
                             criticalPath,
                             lgid,
                             left);
      if(tmposchedulegraphs != null) {
        if(optimizeschedulegraphs == null) {
          optimizeschedulegraphs = new Vector<Vector<ScheduleNode>>();
        }
        optimizeschedulegraphs.addAll(tmposchedulegraphs);
        lgid += tmposchedulegraphs.size();
        left -= tmposchedulegraphs.size();
        if(left == 0) {
          schedulegraph = null;
          criticalPath = null;
          tmposchedulegraphs = null;
          break;
        }
      } 
      schedulegraph = null;
      criticalPath = null;
      tmposchedulegraphs = null;
    }

    return optimizeschedulegraphs;
  }

  private Vector<SimExecutionEdge> 
  analyzeCriticalPath(SimExecutionNode startnode) {
    // first figure out the critical path
    Vector<SimExecutionEdge> criticalPath = new Vector<SimExecutionEdge>();
    getCriticalPath(startnode, criticalPath);
    computeBestStartPoint(criticalPath);

    return criticalPath;
  }

  // TODO: currently only get one critical path. It's possible that there are
  // multiple critical paths and some of them can not be optimized while others
  // can. Need to fix up for this situation.
  private long getCriticalPath(SimExecutionNode startnode, 
                               Vector<SimExecutionEdge> criticalPath) {
    long sum = 0;
    SimExecutionNode snode = startnode;
    // go reversely to find the critical path
    while(snode != null) {
      SimExecutionNode nsnode = null;
      Iterator<SimExecutionEdge> it_iedges = 
        (Iterator<SimExecutionEdge>)snode.inedges();
      while(it_iedges.hasNext()) {
        SimExecutionEdge sedge = it_iedges.next();
        //if(sedge.getWeight() != 0) {    
          SimExecutionNode tsnode = (SimExecutionNode)(sedge.getSource());
          if(tsnode.getTimepoint() + sedge.getWeight() == snode.getTimepoint()) {
            nsnode = tsnode;
            criticalPath.insertElementAt(sedge, 0);
            sum += sedge.getWeight();
            break;
          }
        //}
      }
      it_iedges = null;
      snode = nsnode;
    }
    return sum;
  }

  private void computeBestStartPoint(Vector<SimExecutionEdge> criticalPath) {
    // calculate the earliest start time of each task on the critial path
    for(int i = 0; i < criticalPath.size(); i++) {
      SimExecutionEdge seedge = criticalPath.elementAt(i);
      Vector<SimExecutionEdge> predicates = seedge.getPredicates();
      if(predicates != null) {
        // have predicates
        long starttime = 0;
        // check the latest finish time of all the predicates
        for(int j = 0; j < predicates.size(); j++) {
          SimExecutionEdge predicate = predicates.elementAt(j);
          long tmptime = predicate.getBestStartPoint() + predicate.getWeight();
          if(tmptime > starttime) {
            starttime = tmptime;
            seedge.setLastpredicateEdge(predicate);
            if(predicate.getTd() != null) {
              seedge.setLastpredicateNode(
                  (SimExecutionNode)predicate.getTarget());
            } else {
              // transfer edge
              seedge.setLastpredicateNode(
                  (SimExecutionNode)predicate.getSource());
            }
          }
        }
        seedge.setBestStartPoint(starttime);
      } else if(seedge.getSource().getInedgeVector().size() > 0) {
        // should have only one in edge
        long starttime = ((SimExecutionNode)seedge.getSource()).getTimepoint();
        seedge.setBestStartPoint(starttime);
      } else {
        // no predicates
        seedge.setBestStartPoint(0);
      }
      predicates = null;
    }
  }

  private Vector<Vector<ScheduleNode>> 
  optimizeCriticalPath(Vector<ScheduleNode> scheduleGraph,
                       Vector<SimExecutionEdge> criticalPath,
                       int gid,
                       int count) {
    Vector<Vector<ScheduleNode>> optimizeschedulegraphs = null;
    int lgid = gid;
    int left = count;

    // for test, print out the criticalPath
    if(this.state.PRINTCRITICALPATH) {
      SchedulingUtil.printCriticalPath(this.state.outputdir + "criticalpath_" 
                                       + lgid + ".dot",  criticalPath);
    }

    // first check all seedges whose real start point is late than predicted
    // earliest start time and group them
    long opcheckpoint = Long.MAX_VALUE;
    Vector<Integer> sparecores = null;
    // group according to core index
    Hashtable<Long, Hashtable<Integer, Vector<SimExecutionEdge>>> toselects = 
      new Hashtable<Long, Hashtable<Integer, Vector<SimExecutionEdge>>>();
    Random rand = new Random();
    for(int i = 0; i < criticalPath.size(); i++) {
      SimExecutionEdge seedge = criticalPath.elementAt(i);
      long starttime = seedge.getBestStartPoint();
      if((starttime < ((SimExecutionNode)seedge.getSource()).getTimepoint()) 
          && (seedge.getTd() != null)){
        // Note: must be a task related edge, can not be an object transfer edge
        // no restrictions due to data dependencies
        // have potential to be parallelled and start execution earlier
        seedge.setFixedTime(false);
        // consider to optimize it only when its predicates can NOT 
        // be optimized, otherwise first considering optimize its predicates
        //SimExecutionEdge lastpredicateedge = seedge.getLastpredicateEdge();
        // TODO
        //if(lastpredicateedge.isFixedTime()) {			
          int corenum = seedge.getCoreNum();
          if(!toselects.containsKey(starttime)) {
            toselects.put(starttime, 
                new Hashtable<Integer, Vector<SimExecutionEdge>>());
          }
          if(!toselects.get(starttime).containsKey(corenum)) {
            toselects.get(starttime).put(corenum, 
                new Vector<SimExecutionEdge>());
          }
          toselects.get(starttime).get(corenum).add(seedge);
        //}
      }
    }

    // Randomly choose the tasks to optimize(previously only 
    // consider the tasks with smallest best start time)
    Vector<Long> keys = new Vector<Long>(toselects.keySet());
    do{
      int length = keys.size();
      if(length == 0) {
        return optimizeschedulegraphs;
      }
      int tochoose = Math.abs(rand.nextInt()) % length;
      opcheckpoint = (keys.elementAt(tochoose)).longValue();
      keys.removeElementAt(tochoose);
      Hashtable<Integer, Vector<SimExecutionEdge>> tooptimize = 
        toselects.get(opcheckpoint);
      SimExecutionEdge seedge = 
        tooptimize.values().iterator().next().elementAt(0);
      SimExecutionNode lastpredicatenode = seedge.getLastpredicateNode();
      SimExecutionEdge lastpredicateedge = seedge.getLastpredicateEdge();
      long timepoint = lastpredicatenode.getTimepoint();
      if(lastpredicateedge.getTd() == null) {
        // transfer edge
        timepoint += lastpredicateedge.getWeight();
      }
      // mapping to critical path
      for(int index = 0; index < criticalPath.size(); index++) {
        SimExecutionEdge tmpseedge = criticalPath.elementAt(index);
        SimExecutionNode tmpsenode = 
          (SimExecutionNode)tmpseedge.getTarget();
        if(tmpsenode.getTimepoint() > timepoint) {
          // get the spare core info
          sparecores = tmpsenode.getSpareCores();
          break;
        }
      }

      if(tooptimize.size() > 0) {
        Iterator<Integer> it_cores = tooptimize.keySet().iterator();
        // check if it is possible to optimize these tasks
        if((sparecores == null) || (sparecores.size() == 0)) {
          // lack of spare cores
          while(it_cores.hasNext()) {
            int corenum = it_cores.next();
            Vector<SimExecutionEdge> tmptasks = tooptimize.get(corenum);
            // group the task instantiations according to whether it 
            // has backward data dependences or not
            Vector<SimExecutionEdge> candidatetasks = new Vector();
            for(int ii= 0; ii < tmptasks.size(); ii++) {
              SimExecutionEdge tmpseedge = tmptasks.elementAt(ii);
              SimExecutionNode target = (SimExecutionNode)tmpseedge.getTarget();
              Vector<SimExecutionEdge> children = 
                (Vector<SimExecutionEdge>)target.getEdgeVector();
              int jj = 0;
              for(; jj < children.size(); jj++) {
                SimExecutionEdge tmpedge = children.elementAt(jj);
                if(tmpedge.getTd() != null) {
                  Vector<SimExecutionEdge> predicates = 
                    tmpedge.getPredicates();
                  if((predicates != null) && 
                      (predicates.contains(tmpseedge))) {
                    break;
                  }
                  predicates = null;
                } else if(tmpedge.getWeight() != 0) {
                  // transfer edge
                  if(((SimExecutionNode)tmpedge.getTarget()).getTimepoint() 
                      == tmpedge.getWeight() + target.getTimepoint()) {
                    break;
                  }
                }
              }
              if(jj == children.size()) {
                candidatetasks.add(tmpseedge);
              }
            }
            if((candidatetasks.size() > 0) && 
                (candidatetasks.size() < tmptasks.size())) {
              // there are less important tasks which have no backward
              // data dependences at this timepoint, try to change 
              // original execution order
              Hashtable<Integer, Vector<SimExecutionEdge>> tooptimize2 = 
                new Hashtable<Integer, Vector<SimExecutionEdge>>();
              tooptimize2.put(corenum, candidatetasks);
              Vector<Vector<ScheduleNode>> ops = 
                innerOptimizeCriticalPath(scheduleGraph,
                                          tooptimize2,
                                          null,
                                          lgid,
                                          left);
              if(ops != null) {
                if(optimizeschedulegraphs == null) {
                  optimizeschedulegraphs = new Vector<Vector<ScheduleNode>>();
                }
                optimizeschedulegraphs.addAll(ops);
                lgid += ops.size();
                left -= ops.size();
              }
              tooptimize2 = null;
              ops = null;
            }
            tmptasks = null;
            candidatetasks = null;
          }

          if(left == 0) {
            it_cores = null;
            return optimizeschedulegraphs;
          }

          // flush the dependences and earliest start time
          it_cores = tooptimize.keySet().iterator();
          while(it_cores.hasNext()) {
            int corenum = it_cores.next();
            Vector<SimExecutionEdge> edgevec = 
              tooptimize.get(corenum);
            for(int j = 0; j < edgevec.size(); j++) {
              SimExecutionEdge edge = edgevec.elementAt(j);
              lastpredicateedge = edge.getLastpredicateEdge();
              lastpredicatenode = edge.getLastpredicateNode();
              // if(edge.getCoreNum() != lastpredicate.getCoreNum()) // should never hit this
              timepoint = lastpredicatenode.getTimepoint();
              if(lastpredicateedge.getTd() == null) {
                // transfer edge
                timepoint += lastpredicateedge.getWeight();
              }
              // mapping to critical path
              for(int index = 0; index < criticalPath.size(); index++) {
                SimExecutionEdge tmpseedge = criticalPath.elementAt(index);
                SimExecutionNode tmpsenode = 
                  (SimExecutionNode)tmpseedge.getTarget();
                if(tmpsenode.getTimepoint() > timepoint) {
                  // update the predicate info
                  if(edge.getPredicates() != null) {
                    edge.getPredicates().remove(lastpredicateedge);
                  }
                  edge.addPredicate(criticalPath.elementAt(index));
                  break;
                }
              }
            }
            edgevec = null;
          }
          it_cores = null;
          computeBestStartPoint(criticalPath);
          Vector<Vector<ScheduleNode>> ops = optimizeCriticalPath(scheduleGraph, 
                                                                  criticalPath, 
                                                                  lgid,
                                                                  left);
          if(ops != null) {
            if(optimizeschedulegraphs == null) {
              optimizeschedulegraphs = new Vector<Vector<ScheduleNode>>();
            }
            optimizeschedulegraphs.addAll(ops);
            lgid += ops.size();
            left -= ops.size();
          }
          ops = null;
        } else {
          // there are spare cores, try to reorganize the tasks to the spare 
          // cores
          Vector<Vector<ScheduleNode>> ops = 
            innerOptimizeCriticalPath(scheduleGraph,
                                      tooptimize,
                                      sparecores,
                                      lgid,
                                      left);
          if(ops != null) {
            if(optimizeschedulegraphs == null) {
              optimizeschedulegraphs = new Vector<Vector<ScheduleNode>>();
            }
            optimizeschedulegraphs.addAll(ops);
            lgid += ops.size();
            left -= ops.size();
          }
          ops = null;
        }
      }
      sparecores = null;
      tooptimize.clear();
      tooptimize = null;
    }while(left > 0);
    toselects.clear();
    toselects = null;

    return optimizeschedulegraphs;
  }

  private Vector<Vector<ScheduleNode>> 
  innerOptimizeCriticalPath(Vector<ScheduleNode> scheduleGraph,
                            Hashtable<Integer, Vector<SimExecutionEdge>> tooptimize,
                            Vector<Integer> sparecores,
                            int gid,
                            int count) {
    int lgid = gid;
    int left = count;
    Vector<Vector<ScheduleNode>> optimizeschedulegraphs = null;

    // first clone the whole graph
    Vector<ScheduleNode> newscheduleGraph = 
      cloneScheduleGraph(scheduleGraph, lgid);
    
    if(newscheduleGraph.size() == 0) {
      System.err.println("empty schedule graph!");
      return optimizeschedulegraphs;
    }

    // these nodes are root nodes
    Vector<ScheduleNode> roots = new Vector<ScheduleNode>();
    for(int i = 0; i < newscheduleGraph.size(); i++) {
      if((sparecores == null) || (sparecores.contains(i))) {
        roots.add(newscheduleGraph.elementAt(i));
      }
    }

    // map the tasks associated to SimExecutionedges to original 
    // ClassNode in the ScheduleGraph and split them from previous 
    // ScheduleGraph
    Vector<ScheduleNode> tocombines = new Vector<ScheduleNode>();
    Iterator<Integer> it_cores = tooptimize.keySet().iterator();
    while(it_cores.hasNext()) {
      int corenum = it_cores.next();
      Vector<SimExecutionEdge> candidatetasks = 
        tooptimize.get(corenum);
      for(int i = 0; i < candidatetasks.size(); i++) {
        TaskDescriptor td = candidatetasks.elementAt(i).getTd();
        // TODO: currently do not consider multi-param tasks
        if(td.numParameters() == 1) {
          ClassDescriptor cd = td.getParamType(0).getClassDesc();
          ScheduleNode snode = newscheduleGraph.elementAt(corenum); // corresponding ScheduleNode
          Iterator<ClassNode> it_cnodes = snode.getClassNodesIterator();
          ClassNode tosplit = null;
          while(it_cnodes.hasNext()) {
            ClassNode cnode = it_cnodes.next();
            if(cnode.getClassDescriptor().equals(cd)) {
              tosplit= cnode;
              break;
            }
          }
          it_cnodes = null;

          // split the node
          ScheduleNode splitnode = snode.spliteClassNode(tosplit);          
          newscheduleGraph.add(splitnode);
          tocombines.add(splitnode);
          tosplit = null;
        }
      }
      candidatetasks = null;
    }
    it_cores = null;

    if(tocombines.size() == 0) {
      return optimizeschedulegraphs;
    }

    SchedulingUtil.assignCids(newscheduleGraph);

    // get all the ScheduleEdge
    Vector<ScheduleEdge> scheduleEdges = new Vector<ScheduleEdge>();
    for(int i= 0; i < newscheduleGraph.size(); i++) {
      scheduleEdges.addAll(
          (Vector<ScheduleEdge>)newscheduleGraph.elementAt(i).getEdgeVector());
    }

    Vector<Vector<ScheduleNode>> rootNodes =  
      SchedulingUtil.rangeScheduleNodes(roots);
    if(rootNodes == null) {
      return optimizeschedulegraphs;
    }
    Vector<Vector<ScheduleNode>> nodes2combine = 
      SchedulingUtil.rangeScheduleNodes(tocombines);
    if(nodes2combine == null) {
      return optimizeschedulegraphs;
    }

    CombinationUtil.CombineGenerator cGen = 
      CombinationUtil.allocateCombineGenerator(rootNodes, nodes2combine);
    Random rand = new Random();
    while ((left > 0) && (cGen.nextGen())) {
      if(Math.abs(rand.nextInt()) % 100 > this.generateThreshold) {
        Vector<Vector<CombinationUtil.Combine>> combine = cGen.getCombine();
        Vector<ScheduleNode> sNodes = 
          SchedulingUtil.generateScheduleGraph(this.state,
                                               newscheduleGraph,
                                               scheduleEdges,
                                               rootNodes, 
                                               combine, 
                                               lgid++);
        if(optimizeschedulegraphs == null) {
          optimizeschedulegraphs = new Vector<Vector<ScheduleNode>>();
        }
        optimizeschedulegraphs.add(sNodes);
        combine = null;
        sNodes = null;
        left--;
      }
    }
    cGen.clear();
    for(int i = 0; i < rootNodes.size(); i++) {
      if(rootNodes.elementAt(i) != null) {
        rootNodes.elementAt(i).clear();
      }
    }
    rootNodes = null;
    for(int i = 0; i < nodes2combine.size(); i++) {
      if(nodes2combine.elementAt(i) != null) {
        nodes2combine.elementAt(i).clear();
      }
    }
    nodes2combine = null;
    for(int j = 0; j < newscheduleGraph.size(); j++) {
      ScheduleNode snode = newscheduleGraph.elementAt(j);
      snode.getEdgeVector().clear();
      snode.getInedgeVector().clear();
      snode.getScheduleEdges().clear();
      snode.getClassNodes().clear();
    }
    newscheduleGraph = null;
    scheduleEdges.clear();
    scheduleEdges = null;
    roots = null;
    tocombines = null;

    return optimizeschedulegraphs;
  }

  private Vector<ScheduleNode> 
  cloneScheduleGraph(Vector<ScheduleNode> scheduleGraph,
                     int gid) {
    Vector<ScheduleNode> result = new Vector<ScheduleNode>();

    // get all the ScheduleEdge
    Vector<ScheduleEdge> scheduleEdges = new Vector<ScheduleEdge>();
    for(int i= 0; i < scheduleGraph.size(); i++) {
      scheduleEdges.addAll(
          (Vector<ScheduleEdge>)scheduleGraph.elementAt(i).getEdgeVector());
    }
    Hashtable<ScheduleNode, Hashtable<ClassNode, ClassNode>> sn2hash = 
      new Hashtable<ScheduleNode, Hashtable<ClassNode, ClassNode>>();
    Hashtable<ScheduleNode, ScheduleNode> sn2sn = 
      new Hashtable<ScheduleNode, ScheduleNode>();
    SchedulingUtil.cloneScheduleGraph(scheduleGraph,
        scheduleEdges,
        sn2hash,
        sn2sn,
        result,
        gid);

    SchedulingUtil.assignCids(result);
    scheduleEdges.clear();
    scheduleEdges = null;
    sn2hash.clear();
    sn2hash = null;
    sn2sn.clear();
    sn2sn = null;

    return result;
  }

  private Vector<Schedule> 
  generateScheduling(Vector<ScheduleNode> scheduleGraph,
                     Hashtable<TaskDescriptor, ClassDescriptor> td2maincd) {
    Hashtable<TaskDescriptor, Vector<Schedule>> td2cores = 
      new Hashtable<TaskDescriptor, Vector<Schedule>>(); // tasks reside on which cores
    Vector<Schedule> scheduling = new Vector<Schedule>(scheduleGraph.size());
    // for each ScheduleNode create a schedule node representing a core
    Hashtable<ScheduleNode, Integer> sn2coreNum = 
      new Hashtable<ScheduleNode, Integer>();
    Hashtable<TaskDescriptor, Integer> td2maincore = 
      new Hashtable<TaskDescriptor, Integer>();
    Hashtable<TaskDescriptor, Vector<Schedule>> td2allycores = 
      new Hashtable<TaskDescriptor, Vector<Schedule>>(); // multiparam tasks -- 
                                       // ally cores which might have parameters 
                                       // for the task
    
    int j = 0;
    for(j = 0; j < scheduleGraph.size(); j++) {
      sn2coreNum.put(scheduleGraph.elementAt(j), j);
    }
    int startupcore = 0;
    boolean setstartupcore = false;
    Schedule startup = null;
    int gid = scheduleGraph.elementAt(0).getGid();
    for(j = 0; j < scheduleGraph.size(); j++) {
      Schedule tmpSchedule = new Schedule(j, gid);
      ScheduleNode sn = scheduleGraph.elementAt(j);

      Vector<ClassNode> cNodes = sn.getClassNodes();
      for(int k = 0; k < cNodes.size(); k++) {
        ClassNode cNode = cNodes.elementAt(k);
        ClassDescriptor cd = cNode.getClassDescriptor();
        Iterator it_flags = cNode.getFlags();
        while(it_flags.hasNext()) {
          FlagState fs = (FlagState)it_flags.next();
          Iterator it_edges = fs.edges();
          while(it_edges.hasNext()) {
            FEdge tmpfe = (FEdge)it_edges.next();
            TaskDescriptor td = (tmpfe).getTask();
            boolean contain = true;
            if(td.numParameters() > 1) {
              // td is a multi-param task, check if this core contains the 
              // main cd of it
              ClassDescriptor cd1 = td2maincd.get(td);
              if(td2maincd.get(td).equals(cd)) {
                contain = true;
                td2maincore.put(td, tmpSchedule.getCoreNum());
              } else {
                contain = false;
                if(!td2allycores.containsKey(td)) {
                  td2allycores.put(td, new Vector<Schedule>());
                }
                Vector<Schedule> allycores = td2allycores.get(td);
                if(!allycores.contains(tmpSchedule)) {
                  allycores.addElement(tmpSchedule);
                }
                allycores = null;
              }
              // If the FlagState can be fed to some multi-param tasks,
              // need to record corresponding ally cores later.  
              tmpSchedule.addFState4TD(td, fs);
            }
            if(contain) {
              tmpSchedule.addTask(td);
              if(!td2cores.containsKey(td)) {
                td2cores.put(td, new Vector<Schedule>());
              }
              Vector<Schedule> tmpcores = td2cores.get(td);
              if(!tmpcores.contains(tmpSchedule)) {
                tmpcores.add(tmpSchedule);
              }
              tmpcores = null;
            }
            if(td.getParamType(0).getClassDesc().getSymbol().equals(
                TypeUtil.StartupClass)) {
              assert(!setstartupcore);
              startupcore = j;
              startup = tmpSchedule;
              setstartupcore = true;
            }
          }
          it_edges = null;
        }
        it_flags = null;
      }
      cNodes = null;

      // For each of the ScheduleEdge out of this ScheduleNode, add the 
      // target ScheduleNode into the queue inside sn
      Iterator it_edges = sn.edges();
      while(it_edges.hasNext()) {
        ScheduleEdge se = (ScheduleEdge)it_edges.next();
        ScheduleNode target = (ScheduleNode)se.getTarget();
        Integer targetcore = sn2coreNum.get(target);
        switch(se.getType()) {
        case ScheduleEdge.NEWEDGE: {
          FlagState fs = se.getFstate();
          // Check if the new obj could be fed to some 
          // multi-parameter task, if so, add for ally cores 
          // checking
          Iterator it = fs.edges();
          boolean canTriggerSTask = false; // Flag indicates if fs can trigger
                                           // some single-param task
          while(it.hasNext()) {
            TaskDescriptor td = ((FEdge)it.next()).getTask();
            if(td.numParameters() > 1) {
              tmpSchedule.addFState4TD(td, fs);  // TODO   
              // add this core as a allycore of td
              if(!td2allycores.containsKey(td)) {
                td2allycores.put(td, new Vector<Schedule>());
              }
              Vector<Schedule> allycores = td2allycores.get(td);
              if(!allycores.contains(tmpSchedule)) {
                allycores.addElement(tmpSchedule);
              }
            } else {
              canTriggerSTask = true;
            }
          }
          if(canTriggerSTask) {
            // Only transfer the obj when it can trigger some single-parm task
            // TODO: ensure that multi-param tasks have these objects
            for(int k = 0; k < se.getNewRate(); k++) {
              tmpSchedule.addTargetCore(fs, targetcore);
            }
          }
          break;
        }

        case ScheduleEdge.TRANSEDGE: {
          // 'transmit' edge
          tmpSchedule.addTargetCore(se.getFstate(), 
                                    targetcore, 
                                    se.getTargetFState());
          // check if missed some FlagState associated with some 
          // multi-parameter task, which has been cloned when 
          // splitting a ClassNode
          FlagState fs = se.getSourceFState();
          FlagState tfs = se.getTargetFState();
          Iterator it = tfs.edges();
          while(it.hasNext()) {
            TaskDescriptor td = ((FEdge)it.next()).getTask();
            if(td.numParameters() > 1) {
              tmpSchedule.addFState4TD(td, fs);
              // add this core as a allycore of td
              if(!td2allycores.containsKey(td)) {
                td2allycores.put(td, new Vector<Schedule>());
              }
              Vector<Schedule> allycores = td2allycores.get(td);
              if(!allycores.contains(tmpSchedule)) {
                allycores.addElement(tmpSchedule);
              }
            }
          }
          break;
        }
        }
      }
      it_edges = sn.getScheduleEdgesIterator();
      while(it_edges.hasNext()) {
        ScheduleEdge se = (ScheduleEdge)it_edges.next();
        switch(se.getType()) {
        case ScheduleEdge.NEWEDGE: {
          // TODO, added 09/07/06
          FlagState fs = se.getFstate();
          // Check if the new obj could be fed to some 
          // multi-parameter task, if so, add for ally cores 
          // checking
          Iterator it = fs.edges();
          boolean canTriggerSTask = false; // Flag indicates if fs can trigger
                                           // some single-param task
          while(it.hasNext()) {
            TaskDescriptor td = ((FEdge)it.next()).getTask();
            if(td.numParameters() > 1) {
              tmpSchedule.addFState4TD(td, fs);  // TODO   
              // add this core as a allycore of td
              if(!td2allycores.containsKey(td)) {
                td2allycores.put(td, new Vector<Schedule>());
              }
              Vector<Schedule> allycores = td2allycores.get(td);
              if(!allycores.contains(tmpSchedule)) {
                allycores.addElement(tmpSchedule);
              }
            } else {
              canTriggerSTask = true;
            }
          }
          if(canTriggerSTask) {
            for(int k = 0; k < se.getNewRate(); k++) {
              tmpSchedule.addTargetCore(se.getFstate(), j);
            }
          }
          break;
        }

        case ScheduleEdge.TRANSEDGE: {
          // 'transmit' edge
          tmpSchedule.addTargetCore(se.getFstate(), 
                                    j, 
                                    se.getTargetFState());
          // check if missed some FlagState associated with some 
          // multi-parameter task, which has been cloned when 
          // splitting a ClassNode
          FlagState fs = se.getSourceFState();
          FlagState tfs = se.getTargetFState();
          Iterator it = tfs.edges();
          while(it.hasNext()) {
            TaskDescriptor td = ((FEdge)it.next()).getTask();
            if(td.numParameters() > 1) {
              tmpSchedule.addFState4TD(td, fs);
              // add this core as a allycore of td
              if(!td2allycores.containsKey(td)) {
                td2allycores.put(td, new Vector<Schedule>());
              }
              Vector<Schedule> allycores = td2allycores.get(td);
              if(!allycores.contains(tmpSchedule)) {
                allycores.addElement(tmpSchedule);
              }
            }
          }
          break;
        }
        }
      }
      it_edges = null;
      scheduling.add(tmpSchedule);
    }

    int number = this.coreNum;
    if(scheduling.size() < number) {
      number = scheduling.size();
    }

    Iterator<TaskDescriptor> it_mptds = td2maincd.keySet().iterator();
    while(it_mptds.hasNext()) {
      TaskDescriptor td = it_mptds.next();
      Vector<FEdge> fes = (Vector<FEdge>) this.taskAnalysis.getFEdgesFromTD(td);
      Vector<Schedule> cores = td2cores.get(td); 
      assert(cores.size() == 1); // should have only one core
      for(int k = 0; k < cores.size(); ++k) {
        Schedule tmpSchedule = cores.elementAt(k);

        // Make sure all the parameter objs of a multi-parameter 
        // task would be send to right place after the task finished
        for(int h = 0; h < fes.size(); ++h) {
          FEdge tmpfe = fes.elementAt(h);
          FlagState tmpfs = (FlagState)tmpfe.getTarget();
          Vector<TaskDescriptor> tmptds = new Vector<TaskDescriptor>();
          if((tmpSchedule.getTargetCoreTable() == null) 
              || (!tmpSchedule.getTargetCoreTable().containsKey(tmpfs))) {
            // add up all possible cores' info
            Iterator it_edges = tmpfs.edges();
            while(it_edges.hasNext()) {
              TaskDescriptor tmptd = ((FEdge)it_edges.next()).getTask();
              if(!tmptds.contains(tmptd)) {
                tmptds.add(tmptd);
                // only multiparam task will be processed here!!! TODO
                Vector<Schedule> tmpcores = td2cores.get(tmptd);
                for(int m = 0; m < tmpcores.size(); ++m) {
                  Schedule target = tmpcores.elementAt(m);
                  int targetcore = target.getCoreNum();
                  int num = target.getTaskNum(tmptd);
                  for(int n = 0; n < num; n++) {
                    tmpSchedule.addTargetCore(tmpfs, targetcore);
                  }
                }
                tmpcores = null;
              }
            }
            it_edges = null;
          }
          tmptds = null;
        }
      }
      fes = null;
      cores = null;
    }
    // Make sure all objs which could be feed to a multi-parameter
    // task would be send to all the possible task instances
    it_mptds = td2allycores.keySet().iterator();
    while(it_mptds.hasNext()) {
      TaskDescriptor td = it_mptds.next();
      Vector<Schedule> allycores = td2allycores.get(td);
      for(int i = 0; i < allycores.size(); i++) {
        Schedule tSchedule = allycores.elementAt(i);
        Vector<FlagState> tmpfss = tSchedule.getFStates4TD(td);
        int targetcore = td2maincore.get(td).intValue();
        for(int h = 0; h < tmpfss.size(); ++h) {
          tSchedule.addAllyCore(tmpfss.elementAt(h), targetcore);
        }
        tmpfss = null;
      }
    }
    it_mptds = null;
    td2cores = null;
    sn2coreNum = null;
    td2maincore = null;
    td2allycores = null;

    return scheduling;
  }
}
